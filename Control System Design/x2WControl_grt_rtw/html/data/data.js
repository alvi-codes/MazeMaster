var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"x2WControl","ref":false,"files":[{"name":"x2WControl.c","type":"source","group":"model","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * x2WControl.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"x2WControl.h\"\r\n#include \"rtwtypes.h\"\r\n#include <stddef.h>\r\n#include \"x2WControl_private.h\"\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_x2WControl_T x2WControl_B;\r\n\r\n/* Continuous states */\r\nX_x2WControl_T x2WControl_X;\r\n\r\n/* Block states (default storage) */\r\nDW_x2WControl_T x2WControl_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_x2WControl_T x2WControl_M_;\r\nRT_MODEL_x2WControl_T *const x2WControl_M = &x2WControl_M_;\r\n\r\n/* Projection for root system: '<Root>' */\r\nvoid x2WControl_projection(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeslSimulator *simulator;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  char *msg;\r\n  real_T tmp_0[4];\r\n  real_T time;\r\n  int32_T tmp_2;\r\n  int_T tmp_1[2];\r\n  boolean_T tmp;\r\n\r\n  /* Projection for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n  simulationData = (NeslSimulationData *)x2WControl_DW.STATE_1_SimData;\r\n  time = x2WControl_M->Timing.t[0];\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 4;\r\n  simulationData->mData->mContStates.mX =\r\n    &x2WControl_X.x2WControlPrismatic_Joint1Pzp[0];\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &x2WControl_DW.STATE_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &x2WControl_DW.STATE_1_Modes;\r\n  tmp = false;\r\n  simulationData->mData->mFoundZcEvents = tmp;\r\n  simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(x2WControl_M);\r\n  tmp = false;\r\n  simulationData->mData->mIsSolverAssertCheck = tmp;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  tmp = rtsiIsSolverComputingJacobian(&x2WControl_M->solverInfo);\r\n  simulationData->mData->mIsComputingJacobian = tmp;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\r\n    (&x2WControl_M->solverInfo);\r\n  tmp_1[0] = 0;\r\n  tmp_0[0] = x2WControl_B.INPUT_1_1_1[0];\r\n  tmp_0[1] = x2WControl_B.INPUT_1_1_1[1];\r\n  tmp_0[2] = x2WControl_B.INPUT_1_1_1[2];\r\n  tmp_0[3] = x2WControl_B.INPUT_1_1_1[3];\r\n  tmp_1[1] = 4;\r\n  simulationData->mData->mInputValues.mN = 4;\r\n  simulationData->mData->mInputValues.mX = &tmp_0[0];\r\n  simulationData->mData->mInputOffsets.mN = 2;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_1[0];\r\n  simulator = (NeslSimulator *)x2WControl_DW.STATE_1_Simulator;\r\n  diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  tmp_2 = ne_simulator_method(simulator, NESL_SIM_PROJECTION, simulationData,\r\n    diagnosticManager);\r\n  if (tmp_2 != 0) {\r\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n    if (tmp) {\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(x2WControl_M, msg);\r\n    }\r\n  }\r\n\r\n  /* End of Projection for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n}\r\n\r\n/*\r\n * This function updates continuous states using the ODE3 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  /* Solver Matrices */\r\n  static const real_T rt_ODE3_A[3] = {\r\n    1.0/2.0, 3.0/4.0, 1.0\r\n  };\r\n\r\n  static const real_T rt_ODE3_B[3][3] = {\r\n    { 1.0/2.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 3.0/4.0, 0.0 },\r\n\r\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\r\n  };\r\n\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T hB[3];\r\n  int_T i;\r\n  int_T nXc = 8;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  x2WControl_derivatives();\r\n\r\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\r\n  hB[0] = h * rt_ODE3_B[0][0];\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\r\n  rtsiSetdX(si, f1);\r\n  x2WControl_step();\r\n  x2WControl_derivatives();\r\n\r\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\r\n  for (i = 0; i <= 1; i++) {\r\n    hB[i] = h * rt_ODE3_B[1][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\r\n  rtsiSetdX(si, f2);\r\n  x2WControl_step();\r\n  x2WControl_derivatives();\r\n\r\n  /* tnew = t + hA(3);\r\n     ynew = y + f*hB(:,3); */\r\n  for (i = 0; i <= 2; i++) {\r\n    hB[i] = h * rt_ODE3_B[2][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  x2WControl_step();\r\n  x2WControl_projection();\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\n/* Model step function */\r\nvoid x2WControl_step(void)\r\n{\r\n  if (rtmIsMajorTimeStep(x2WControl_M)) {\r\n    /* set solver stop time */\r\n    if (!(x2WControl_M->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&x2WControl_M->solverInfo,\r\n                            ((x2WControl_M->Timing.clockTickH0 + 1) *\r\n        x2WControl_M->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&x2WControl_M->solverInfo,\r\n                            ((x2WControl_M->Timing.clockTick0 + 1) *\r\n        x2WControl_M->Timing.stepSize0 + x2WControl_M->Timing.clockTickH0 *\r\n        x2WControl_M->Timing.stepSize0 * 4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(x2WControl_M)) {\r\n    x2WControl_M->Timing.t[0] = rtsiGetT(&x2WControl_M->solverInfo);\r\n  }\r\n\r\n  {\r\n    NeslSimulationData *simulationData;\r\n    NeslSimulator *simulator;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    real_T tmp_2[8];\r\n    real_T tmp[4];\r\n    real_T currentTime;\r\n    real_T time;\r\n    real_T time_0;\r\n    real_T time_1;\r\n    real_T time_2;\r\n    int32_T tmp_1;\r\n    int_T tmp_3[3];\r\n    int_T tmp_0[2];\r\n    boolean_T first_output;\r\n\r\n    /* SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n    simulationData = (NeslSimulationData *)x2WControl_DW.STATE_1_SimData;\r\n    time = x2WControl_M->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time;\r\n    simulationData->mData->mContStates.mN = 4;\r\n    simulationData->mData->mContStates.mX =\r\n      &x2WControl_X.x2WControlPrismatic_Joint1Pzp[0];\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &x2WControl_DW.STATE_1_Discrete;\r\n    simulationData->mData->mModeVector.mN = 0;\r\n    simulationData->mData->mModeVector.mX = &x2WControl_DW.STATE_1_Modes;\r\n    first_output = false;\r\n    simulationData->mData->mFoundZcEvents = first_output;\r\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(x2WControl_M);\r\n    first_output = false;\r\n    simulationData->mData->mIsSolverAssertCheck = first_output;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    first_output = rtsiIsSolverComputingJacobian(&x2WControl_M->solverInfo);\r\n    simulationData->mData->mIsComputingJacobian = first_output;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\r\n      (&x2WControl_M->solverInfo);\r\n    tmp_0[0] = 0;\r\n    tmp[0] = x2WControl_B.INPUT_1_1_1[0];\r\n    tmp[1] = x2WControl_B.INPUT_1_1_1[1];\r\n    tmp[2] = x2WControl_B.INPUT_1_1_1[2];\r\n    tmp[3] = x2WControl_B.INPUT_1_1_1[3];\r\n    tmp_0[1] = 4;\r\n    simulationData->mData->mInputValues.mN = 4;\r\n    simulationData->mData->mInputValues.mX = &tmp[0];\r\n    simulationData->mData->mInputOffsets.mN = 2;\r\n    simulationData->mData->mInputOffsets.mX = &tmp_0[0];\r\n    simulationData->mData->mOutputs.mN = 4;\r\n    simulationData->mData->mOutputs.mX = &x2WControl_B.STATE_1[0];\r\n    simulationData->mData->mTolerances.mN = 0;\r\n    simulationData->mData->mTolerances.mX = NULL;\r\n    simulationData->mData->mCstateHasChanged = false;\r\n    time_0 = x2WControl_M->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time_0;\r\n    simulationData->mData->mSampleHits.mN = 0;\r\n    simulationData->mData->mSampleHits.mX = NULL;\r\n    simulationData->mData->mIsFundamentalSampleHit = false;\r\n    simulator = (NeslSimulator *)x2WControl_DW.STATE_1_Simulator;\r\n    diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_1 = ne_simulator_method(simulator, NESL_SIM_OUTPUTS, simulationData,\r\n      diagnosticManager);\r\n    if (tmp_1 != 0) {\r\n      first_output = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n      if (first_output) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(x2WControl_M, msg);\r\n      }\r\n    }\r\n\r\n    /* End of SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n\r\n    /* SimscapeExecutionBlock: '<S60>/OUTPUT_1_0' */\r\n    simulationData = (NeslSimulationData *)x2WControl_DW.OUTPUT_1_0_SimData;\r\n    time_1 = x2WControl_M->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time_1;\r\n    simulationData->mData->mContStates.mN = 0;\r\n    simulationData->mData->mContStates.mX = NULL;\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &x2WControl_DW.OUTPUT_1_0_Discrete;\r\n    simulationData->mData->mModeVector.mN = 0;\r\n    simulationData->mData->mModeVector.mX = &x2WControl_DW.OUTPUT_1_0_Modes;\r\n    first_output = false;\r\n    simulationData->mData->mFoundZcEvents = first_output;\r\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(x2WControl_M);\r\n    first_output = false;\r\n    simulationData->mData->mIsSolverAssertCheck = first_output;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    simulationData->mData->mIsComputingJacobian = false;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\r\n      (&x2WControl_M->solverInfo);\r\n    tmp_3[0] = 0;\r\n    tmp_2[0] = x2WControl_B.INPUT_1_1_1[0];\r\n    tmp_2[1] = x2WControl_B.INPUT_1_1_1[1];\r\n    tmp_2[2] = x2WControl_B.INPUT_1_1_1[2];\r\n    tmp_2[3] = x2WControl_B.INPUT_1_1_1[3];\r\n    tmp_3[1] = 4;\r\n    tmp_2[4] = x2WControl_B.STATE_1[0];\r\n    tmp_2[5] = x2WControl_B.STATE_1[1];\r\n    tmp_2[6] = x2WControl_B.STATE_1[2];\r\n    tmp_2[7] = x2WControl_B.STATE_1[3];\r\n    tmp_3[2] = 8;\r\n    simulationData->mData->mInputValues.mN = 8;\r\n    simulationData->mData->mInputValues.mX = &tmp_2[0];\r\n    simulationData->mData->mInputOffsets.mN = 3;\r\n    simulationData->mData->mInputOffsets.mX = &tmp_3[0];\r\n    simulationData->mData->mOutputs.mN = 1;\r\n\r\n    /* SimscapeExecutionBlock: '<S60>/OUTPUT_1_0' */\r\n    simulationData->mData->mOutputs.mX = &x2WControl_B.OUTPUT_1_0;\r\n\r\n    /* SimscapeExecutionBlock: '<S60>/OUTPUT_1_0' */\r\n    simulationData->mData->mTolerances.mN = 0;\r\n    simulationData->mData->mTolerances.mX = NULL;\r\n    simulationData->mData->mCstateHasChanged = false;\r\n    time_2 = x2WControl_M->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time_2;\r\n    simulationData->mData->mSampleHits.mN = 0;\r\n    simulationData->mData->mSampleHits.mX = NULL;\r\n    simulationData->mData->mIsFundamentalSampleHit = false;\r\n    simulator = (NeslSimulator *)x2WControl_DW.OUTPUT_1_0_Simulator;\r\n    diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.OUTPUT_1_0_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_1 = ne_simulator_method(simulator, NESL_SIM_OUTPUTS, simulationData,\r\n      diagnosticManager);\r\n    if (tmp_1 != 0) {\r\n      first_output = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n      if (first_output) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(x2WControl_M, msg);\r\n      }\r\n    }\r\n\r\n    /* Gain: '<Root>/Gain' */\r\n    x2WControl_B.Gain = x2WControl_P.Gain_Gain * x2WControl_B.OUTPUT_1_0;\r\n    if (rtmIsMajorTimeStep(x2WControl_M)) {\r\n    }\r\n\r\n    /* Step: '<Root>/Step' */\r\n    currentTime = x2WControl_M->Timing.t[0];\r\n    if (currentTime < x2WControl_P.Step_Time) {\r\n      /* Step: '<Root>/Step' */\r\n      x2WControl_B.Step = x2WControl_P.Step_Y0;\r\n    } else {\r\n      /* Step: '<Root>/Step' */\r\n      x2WControl_B.Step = x2WControl_P.Step_YFinal;\r\n    }\r\n\r\n    /* End of Step: '<Root>/Step' */\r\n    if (rtmIsMajorTimeStep(x2WControl_M)) {\r\n    }\r\n\r\n    /* Sum: '<Root>/Sum' */\r\n    x2WControl_B.Sum = x2WControl_B.Step - x2WControl_B.Gain;\r\n\r\n    /* Gain: '<S35>/Derivative Gain' */\r\n    x2WControl_B.DerivativeGain = x2WControl_P.PIDController_D *\r\n      x2WControl_B.Sum;\r\n\r\n    /* Integrator: '<S36>/Filter' */\r\n    x2WControl_B.Filter = x2WControl_X.Filter_CSTATE;\r\n\r\n    /* Sum: '<S36>/SumD' */\r\n    x2WControl_B.SumD = x2WControl_B.DerivativeGain - x2WControl_B.Filter;\r\n\r\n    /* Gain: '<S38>/Integral Gain' */\r\n    x2WControl_B.IntegralGain = x2WControl_P.PIDController_I * x2WControl_B.Sum;\r\n\r\n    /* Integrator: '<S41>/Integrator' */\r\n    x2WControl_B.Integrator = x2WControl_X.Integrator_CSTATE;\r\n\r\n    /* Gain: '<S44>/Filter Coefficient' */\r\n    x2WControl_B.FilterCoefficient = x2WControl_P.PIDController_N *\r\n      x2WControl_B.SumD;\r\n\r\n    /* Gain: '<S46>/Proportional Gain' */\r\n    x2WControl_B.ProportionalGain = x2WControl_P.PIDController_P *\r\n      x2WControl_B.Sum;\r\n\r\n    /* Sum: '<S50>/Sum' */\r\n    x2WControl_B.Sum_k = (x2WControl_B.ProportionalGain +\r\n                          x2WControl_B.Integrator) +\r\n      x2WControl_B.FilterCoefficient;\r\n\r\n    /* SimscapeInputBlock: '<S60>/INPUT_1_1_1' */\r\n    if (x2WControl_DW.INPUT_1_1_1_FirstOutput == 0.0) {\r\n      x2WControl_DW.INPUT_1_1_1_FirstOutput = 1.0;\r\n      x2WControl_X.x2WControlSimulink_PS_Converter[0] = x2WControl_B.Sum_k;\r\n      x2WControl_X.x2WControlSimulink_PS_Converter[1] = 0.0;\r\n    }\r\n\r\n    x2WControl_B.INPUT_1_1_1[0] = x2WControl_X.x2WControlSimulink_PS_Converter[0];\r\n    x2WControl_B.INPUT_1_1_1[1] = x2WControl_X.x2WControlSimulink_PS_Converter[1];\r\n    x2WControl_B.INPUT_1_1_1[2] = ((x2WControl_B.Sum_k -\r\n      x2WControl_X.x2WControlSimulink_PS_Converter[0]) * 1000.0 - 2.0 *\r\n      x2WControl_X.x2WControlSimulink_PS_Converter[1]) * 1000.0;\r\n    x2WControl_B.INPUT_1_1_1[3] = 0.0;\r\n\r\n    /* End of SimscapeInputBlock: '<S60>/INPUT_1_1_1' */\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(x2WControl_M)) {\r\n    /* Matfile logging */\r\n    rt_UpdateTXYLogVars(x2WControl_M->rtwLogInfo, (x2WControl_M->Timing.t));\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(x2WControl_M)) {\r\n    NeslSimulationData *simulationData;\r\n    NeslSimulator *simulator;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    real_T tmp_0[4];\r\n    real_T time;\r\n    int32_T tmp_2;\r\n    int_T tmp_1[2];\r\n    boolean_T tmp;\r\n\r\n    /* Update for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n    simulationData = (NeslSimulationData *)x2WControl_DW.STATE_1_SimData;\r\n    time = x2WControl_M->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time;\r\n    simulationData->mData->mContStates.mN = 4;\r\n    simulationData->mData->mContStates.mX =\r\n      &x2WControl_X.x2WControlPrismatic_Joint1Pzp[0];\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &x2WControl_DW.STATE_1_Discrete;\r\n    simulationData->mData->mModeVector.mN = 0;\r\n    simulationData->mData->mModeVector.mX = &x2WControl_DW.STATE_1_Modes;\r\n    tmp = false;\r\n    simulationData->mData->mFoundZcEvents = tmp;\r\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(x2WControl_M);\r\n    tmp = false;\r\n    simulationData->mData->mIsSolverAssertCheck = tmp;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    tmp = rtsiIsSolverComputingJacobian(&x2WControl_M->solverInfo);\r\n    simulationData->mData->mIsComputingJacobian = tmp;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\r\n      (&x2WControl_M->solverInfo);\r\n    tmp_1[0] = 0;\r\n    tmp_0[0] = x2WControl_B.INPUT_1_1_1[0];\r\n    tmp_0[1] = x2WControl_B.INPUT_1_1_1[1];\r\n    tmp_0[2] = x2WControl_B.INPUT_1_1_1[2];\r\n    tmp_0[3] = x2WControl_B.INPUT_1_1_1[3];\r\n    tmp_1[1] = 4;\r\n    simulationData->mData->mInputValues.mN = 4;\r\n    simulationData->mData->mInputValues.mX = &tmp_0[0];\r\n    simulationData->mData->mInputOffsets.mN = 2;\r\n    simulationData->mData->mInputOffsets.mX = &tmp_1[0];\r\n    simulator = (NeslSimulator *)x2WControl_DW.STATE_1_Simulator;\r\n    diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_2 = ne_simulator_method(simulator, NESL_SIM_UPDATE, simulationData,\r\n      diagnosticManager);\r\n    if (tmp_2 != 0) {\r\n      tmp = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n      if (tmp) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(x2WControl_M, msg);\r\n      }\r\n    }\r\n\r\n    /* End of Update for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(x2WControl_M)) {\r\n    /* signal main to stop simulation */\r\n    {                                  /* Sample time: [0.0s, 0.0s] */\r\n      if ((rtmGetTFinal(x2WControl_M)!=-1) &&\r\n          !((rtmGetTFinal(x2WControl_M)-(((x2WControl_M->Timing.clockTick1+\r\n               x2WControl_M->Timing.clockTickH1* 4294967296.0)) * 0.2)) >\r\n            (((x2WControl_M->Timing.clockTick1+x2WControl_M->Timing.clockTickH1*\r\n               4294967296.0)) * 0.2) * (DBL_EPSILON))) {\r\n        rtmSetErrorStatus(x2WControl_M, \"Simulation finished\");\r\n      }\r\n    }\r\n\r\n    rt_ertODEUpdateContinuousStates(&x2WControl_M->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++x2WControl_M->Timing.clockTick0)) {\r\n      ++x2WControl_M->Timing.clockTickH0;\r\n    }\r\n\r\n    x2WControl_M->Timing.t[0] = rtsiGetSolverStopTime(&x2WControl_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [0.2s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 0.2, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      x2WControl_M->Timing.clockTick1++;\r\n      if (!x2WControl_M->Timing.clockTick1) {\r\n        x2WControl_M->Timing.clockTickH1++;\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid x2WControl_derivatives(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeslSimulator *simulator;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  XDot_x2WControl_T *_rtXdot;\r\n  char *msg;\r\n  real_T tmp_0[4];\r\n  real_T time;\r\n  int32_T tmp_2;\r\n  int_T tmp_1[2];\r\n  boolean_T tmp;\r\n  _rtXdot = ((XDot_x2WControl_T *) x2WControl_M->derivs);\r\n\r\n  /* Derivatives for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n  simulationData = (NeslSimulationData *)x2WControl_DW.STATE_1_SimData;\r\n  time = x2WControl_M->Timing.t[0];\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 4;\r\n  simulationData->mData->mContStates.mX =\r\n    &x2WControl_X.x2WControlPrismatic_Joint1Pzp[0];\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &x2WControl_DW.STATE_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &x2WControl_DW.STATE_1_Modes;\r\n  tmp = false;\r\n  simulationData->mData->mFoundZcEvents = tmp;\r\n  simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(x2WControl_M);\r\n  tmp = false;\r\n  simulationData->mData->mIsSolverAssertCheck = tmp;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  tmp = rtsiIsSolverComputingJacobian(&x2WControl_M->solverInfo);\r\n  simulationData->mData->mIsComputingJacobian = tmp;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\r\n    (&x2WControl_M->solverInfo);\r\n  tmp_1[0] = 0;\r\n  tmp_0[0] = x2WControl_B.INPUT_1_1_1[0];\r\n  tmp_0[1] = x2WControl_B.INPUT_1_1_1[1];\r\n  tmp_0[2] = x2WControl_B.INPUT_1_1_1[2];\r\n  tmp_0[3] = x2WControl_B.INPUT_1_1_1[3];\r\n  tmp_1[1] = 4;\r\n  simulationData->mData->mInputValues.mN = 4;\r\n  simulationData->mData->mInputValues.mX = &tmp_0[0];\r\n  simulationData->mData->mInputOffsets.mN = 2;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_1[0];\r\n  simulationData->mData->mDx.mN = 4;\r\n  simulationData->mData->mDx.mX = &_rtXdot->x2WControlPrismatic_Joint1Pzp[0];\r\n  simulator = (NeslSimulator *)x2WControl_DW.STATE_1_Simulator;\r\n  diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  tmp_2 = ne_simulator_method(simulator, NESL_SIM_DERIVATIVES, simulationData,\r\n    diagnosticManager);\r\n  if (tmp_2 != 0) {\r\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n    if (tmp) {\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(x2WControl_M, msg);\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n\r\n  /* Derivatives for Integrator: '<S36>/Filter' */\r\n  _rtXdot->Filter_CSTATE = x2WControl_B.FilterCoefficient;\r\n\r\n  /* Derivatives for Integrator: '<S41>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = x2WControl_B.IntegralGain;\r\n\r\n  /* Derivatives for SimscapeInputBlock: '<S60>/INPUT_1_1_1' */\r\n  _rtXdot->x2WControlSimulink_PS_Converter[0] =\r\n    x2WControl_X.x2WControlSimulink_PS_Converter[1];\r\n  _rtXdot->x2WControlSimulink_PS_Converter[1] = ((x2WControl_B.Sum_k -\r\n    x2WControl_X.x2WControlSimulink_PS_Converter[0]) * 1000.0 - 2.0 *\r\n    x2WControl_X.x2WControlSimulink_PS_Converter[1]) * 1000.0;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid x2WControl_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)x2WControl_M, 0,\r\n                sizeof(RT_MODEL_x2WControl_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&x2WControl_M->solverInfo,\r\n                          &x2WControl_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&x2WControl_M->solverInfo, &rtmGetTPtr(x2WControl_M));\r\n    rtsiSetStepSizePtr(&x2WControl_M->solverInfo,\r\n                       &x2WControl_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&x2WControl_M->solverInfo, &x2WControl_M->derivs);\r\n    rtsiSetContStatesPtr(&x2WControl_M->solverInfo, (real_T **)\r\n                         &x2WControl_M->contStates);\r\n    rtsiSetNumContStatesPtr(&x2WControl_M->solverInfo,\r\n      &x2WControl_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&x2WControl_M->solverInfo,\r\n      &x2WControl_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&x2WControl_M->solverInfo,\r\n      &x2WControl_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&x2WControl_M->solverInfo,\r\n      &x2WControl_M->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&x2WControl_M->solverInfo, (&rtmGetErrorStatus\r\n      (x2WControl_M)));\r\n    rtsiSetRTModelPtr(&x2WControl_M->solverInfo, x2WControl_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&x2WControl_M->solverInfo, MAJOR_TIME_STEP);\r\n  x2WControl_M->intgData.y = x2WControl_M->odeY;\r\n  x2WControl_M->intgData.f[0] = x2WControl_M->odeF[0];\r\n  x2WControl_M->intgData.f[1] = x2WControl_M->odeF[1];\r\n  x2WControl_M->intgData.f[2] = x2WControl_M->odeF[2];\r\n  x2WControl_M->contStates = ((X_x2WControl_T *) &x2WControl_X);\r\n  rtsiSetSolverData(&x2WControl_M->solverInfo, (void *)&x2WControl_M->intgData);\r\n  rtsiSetIsMinorTimeStepWithModeChange(&x2WControl_M->solverInfo, false);\r\n  rtsiSetSolverName(&x2WControl_M->solverInfo,\"ode3\");\r\n  rtmSetTPtr(x2WControl_M, &x2WControl_M->Timing.tArray[0]);\r\n  rtmSetTFinal(x2WControl_M, 10.0);\r\n  x2WControl_M->Timing.stepSize0 = 0.2;\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    x2WControl_M->rtwLogInfo = &rt_DataLoggingInfo;\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(x2WControl_M->rtwLogInfo, (NULL));\r\n    rtliSetLogXSignalPtrs(x2WControl_M->rtwLogInfo, (NULL));\r\n    rtliSetLogT(x2WControl_M->rtwLogInfo, \"tout\");\r\n    rtliSetLogX(x2WControl_M->rtwLogInfo, \"\");\r\n    rtliSetLogXFinal(x2WControl_M->rtwLogInfo, \"\");\r\n    rtliSetLogVarNameModifier(x2WControl_M->rtwLogInfo, \"rt_\");\r\n    rtliSetLogFormat(x2WControl_M->rtwLogInfo, 4);\r\n    rtliSetLogMaxRows(x2WControl_M->rtwLogInfo, 10000);\r\n    rtliSetLogDecimation(x2WControl_M->rtwLogInfo, 1);\r\n    rtliSetLogY(x2WControl_M->rtwLogInfo, \"\");\r\n    rtliSetLogYSignalInfo(x2WControl_M->rtwLogInfo, (NULL));\r\n    rtliSetLogYSignalPtrs(x2WControl_M->rtwLogInfo, (NULL));\r\n  }\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &x2WControl_B), 0,\r\n                sizeof(B_x2WControl_T));\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)&x2WControl_X, 0,\r\n                  sizeof(X_x2WControl_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&x2WControl_DW, 0,\r\n                sizeof(DW_x2WControl_T));\r\n\r\n  /* Matfile logging */\r\n  rt_StartDataLoggingWithStartTime(x2WControl_M->rtwLogInfo, 0.0, rtmGetTFinal\r\n    (x2WControl_M), x2WControl_M->Timing.stepSize0, (&rtmGetErrorStatus\r\n    (x2WControl_M)));\r\n\r\n  {\r\n    NeModelParameters modelParameters;\r\n    NeModelParameters modelParameters_0;\r\n    NeslSimulationData *tmp;\r\n    NeslSimulator *simulator;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    real_T tmp_0;\r\n    int32_T tmp_1;\r\n    boolean_T zcDisabled;\r\n\r\n    /* Start for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n    simulator = nesl_lease_simulator(\"x2WControl/Solver Configuration_1\", 0, 0);\r\n    x2WControl_DW.STATE_1_Simulator = (void *)simulator;\r\n    zcDisabled = pointer_is_null(x2WControl_DW.STATE_1_Simulator);\r\n    if (zcDisabled) {\r\n      x2WControl_a151ee3d_1_gateway();\r\n      simulator = nesl_lease_simulator(\"x2WControl/Solver Configuration_1\", 0, 0);\r\n      x2WControl_DW.STATE_1_Simulator = (void *)simulator;\r\n    }\r\n\r\n    tmp = nesl_create_simulation_data();\r\n    x2WControl_DW.STATE_1_SimData = (void *)tmp;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    x2WControl_DW.STATE_1_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters.mSolverAbsTol = 0.001;\r\n    modelParameters.mSolverRelTol = 0.001;\r\n    modelParameters.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters.mStartTime = 0.0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mUseSimState = false;\r\n    modelParameters.mLinTrimCompile = false;\r\n    modelParameters.mLoggingMode = SSC_LOGGING_ON;\r\n    modelParameters.mRTWModifiedTimeStamp = 6.07273323E+8;\r\n    modelParameters.mUseModelRefSolver = false;\r\n    tmp_0 = 0.001;\r\n    modelParameters.mSolverTolerance = tmp_0;\r\n    tmp_0 = 0.2;\r\n    modelParameters.mFixedStepSize = tmp_0;\r\n    zcDisabled = false;\r\n    modelParameters.mVariableStepSolver = zcDisabled;\r\n    zcDisabled = false;\r\n    modelParameters.mIsUsingODEN = zcDisabled;\r\n    modelParameters.mZcDisabled = true;\r\n    simulator = (NeslSimulator *)x2WControl_DW.STATE_1_Simulator;\r\n    diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_1 = nesl_initialize_simulator(simulator, &modelParameters,\r\n      diagnosticManager);\r\n    if (tmp_1 != 0) {\r\n      zcDisabled = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n      if (zcDisabled) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(x2WControl_M, msg);\r\n      }\r\n    }\r\n\r\n    /* End of Start for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n\r\n    /* Start for SimscapeExecutionBlock: '<S60>/OUTPUT_1_0' */\r\n    simulator = nesl_lease_simulator(\"x2WControl/Solver Configuration_1\", 1, 0);\r\n    x2WControl_DW.OUTPUT_1_0_Simulator = (void *)simulator;\r\n    zcDisabled = pointer_is_null(x2WControl_DW.OUTPUT_1_0_Simulator);\r\n    if (zcDisabled) {\r\n      x2WControl_a151ee3d_1_gateway();\r\n      simulator = nesl_lease_simulator(\"x2WControl/Solver Configuration_1\", 1, 0);\r\n      x2WControl_DW.OUTPUT_1_0_Simulator = (void *)simulator;\r\n    }\r\n\r\n    tmp = nesl_create_simulation_data();\r\n    x2WControl_DW.OUTPUT_1_0_SimData = (void *)tmp;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    x2WControl_DW.OUTPUT_1_0_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_0.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_0.mSolverAbsTol = 0.001;\r\n    modelParameters_0.mSolverRelTol = 0.001;\r\n    modelParameters_0.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters_0.mStartTime = 0.0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mUseSimState = false;\r\n    modelParameters_0.mLinTrimCompile = false;\r\n    modelParameters_0.mLoggingMode = SSC_LOGGING_ON;\r\n    modelParameters_0.mRTWModifiedTimeStamp = 6.07273323E+8;\r\n    modelParameters_0.mUseModelRefSolver = false;\r\n    tmp_0 = 0.001;\r\n    modelParameters_0.mSolverTolerance = tmp_0;\r\n    tmp_0 = 0.2;\r\n    modelParameters_0.mFixedStepSize = tmp_0;\r\n    zcDisabled = false;\r\n    modelParameters_0.mVariableStepSolver = zcDisabled;\r\n    zcDisabled = false;\r\n    modelParameters_0.mIsUsingODEN = zcDisabled;\r\n    modelParameters_0.mZcDisabled = true;\r\n    simulator = (NeslSimulator *)x2WControl_DW.OUTPUT_1_0_Simulator;\r\n    diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.OUTPUT_1_0_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_1 = nesl_initialize_simulator(simulator, &modelParameters_0,\r\n      diagnosticManager);\r\n    if (tmp_1 != 0) {\r\n      zcDisabled = error_buffer_is_empty(rtmGetErrorStatus(x2WControl_M));\r\n      if (zcDisabled) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(x2WControl_M, msg);\r\n      }\r\n    }\r\n\r\n    /* End of Start for SimscapeExecutionBlock: '<S60>/OUTPUT_1_0' */\r\n  }\r\n\r\n  /* InitializeConditions for Integrator: '<S36>/Filter' */\r\n  x2WControl_X.Filter_CSTATE = x2WControl_P.PIDController_InitialConditionF;\r\n\r\n  /* InitializeConditions for Integrator: '<S41>/Integrator' */\r\n  x2WControl_X.Integrator_CSTATE = x2WControl_P.PIDController_InitialConditio_m;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid x2WControl_terminate(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n\r\n  /* Terminate for SimscapeExecutionBlock: '<S60>/STATE_1' */\r\n  diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.STATE_1_DiagMgr;\r\n  neu_destroy_diagnostic_manager(diagnosticManager);\r\n  simulationData = (NeslSimulationData *)x2WControl_DW.STATE_1_SimData;\r\n  nesl_destroy_simulation_data(simulationData);\r\n  nesl_erase_simulator(\"x2WControl/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n\r\n  /* Terminate for SimscapeExecutionBlock: '<S60>/OUTPUT_1_0' */\r\n  diagnosticManager = (NeuDiagnosticManager *)x2WControl_DW.OUTPUT_1_0_DiagMgr;\r\n  neu_destroy_diagnostic_manager(diagnosticManager);\r\n  simulationData = (NeslSimulationData *)x2WControl_DW.OUTPUT_1_0_SimData;\r\n  nesl_destroy_simulation_data(simulationData);\r\n  nesl_erase_simulator(\"x2WControl/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n}\r\n"},{"name":"x2WControl.h","type":"header","group":"model","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * x2WControl.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_x2WControl_h_\r\n#define RTW_HEADER_x2WControl_h_\r\n#ifndef x2WControl_COMMON_INCLUDES_\r\n#define x2WControl_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"rt_logging.h\"\r\n#include \"nesl_rtw.h\"\r\n#include \"x2WControl_a151ee3d_1_gateway.h\"\r\n#endif                                 /* x2WControl_COMMON_INCLUDES_ */\r\n\r\n#include \"x2WControl_types.h\"\r\n#include <float.h>\r\n#include <string.h>\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWLogInfo\r\n#define rtmGetRTWLogInfo(rtm)          ((rtm)->rtwLogInfo)\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T STATE_1[4];                   /* '<S60>/STATE_1' */\r\n  real_T OUTPUT_1_0;                   /* '<S60>/OUTPUT_1_0' */\r\n  real_T Gain;                         /* '<Root>/Gain' */\r\n  real_T Step;                         /* '<Root>/Step' */\r\n  real_T Sum;                          /* '<Root>/Sum' */\r\n  real_T DerivativeGain;               /* '<S35>/Derivative Gain' */\r\n  real_T Filter;                       /* '<S36>/Filter' */\r\n  real_T SumD;                         /* '<S36>/SumD' */\r\n  real_T IntegralGain;                 /* '<S38>/Integral Gain' */\r\n  real_T Integrator;                   /* '<S41>/Integrator' */\r\n  real_T FilterCoefficient;            /* '<S44>/Filter Coefficient' */\r\n  real_T ProportionalGain;             /* '<S46>/Proportional Gain' */\r\n  real_T Sum_k;                        /* '<S50>/Sum' */\r\n  real_T INPUT_1_1_1[4];               /* '<S60>/INPUT_1_1_1' */\r\n} B_x2WControl_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T INPUT_1_1_1_Discrete;         /* '<S60>/INPUT_1_1_1' */\r\n  real_T INPUT_1_1_1_FirstOutput;      /* '<S60>/INPUT_1_1_1' */\r\n  real_T STATE_1_Discrete;             /* '<S60>/STATE_1' */\r\n  real_T OUTPUT_1_0_Discrete;          /* '<S60>/OUTPUT_1_0' */\r\n  void* STATE_1_Simulator;             /* '<S60>/STATE_1' */\r\n  void* STATE_1_SimData;               /* '<S60>/STATE_1' */\r\n  void* STATE_1_DiagMgr;               /* '<S60>/STATE_1' */\r\n  void* STATE_1_ZcLogger;              /* '<S60>/STATE_1' */\r\n  void* STATE_1_TsInfo;                /* '<S60>/STATE_1' */\r\n  void* OUTPUT_1_0_Simulator;          /* '<S60>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_SimData;            /* '<S60>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_DiagMgr;            /* '<S60>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_ZcLogger;           /* '<S60>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_TsInfo;             /* '<S60>/OUTPUT_1_0' */\r\n  void* SINK_1_RtwLogger;              /* '<S60>/SINK_1' */\r\n  void* SINK_1_RtwLogBuffer;           /* '<S60>/SINK_1' */\r\n  void* SINK_1_RtwLogFcnManager;       /* '<S60>/SINK_1' */\r\n  int_T STATE_1_Modes;                 /* '<S60>/STATE_1' */\r\n  int_T OUTPUT_1_0_Modes;              /* '<S60>/OUTPUT_1_0' */\r\n  boolean_T STATE_1_FirstOutput;       /* '<S60>/STATE_1' */\r\n  boolean_T OUTPUT_1_0_FirstOutput;    /* '<S60>/OUTPUT_1_0' */\r\n} DW_x2WControl_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T x2WControlPrismatic_Joint1Pzp[4];/* '<S60>/STATE_1' */\r\n  real_T Filter_CSTATE;                /* '<S36>/Filter' */\r\n  real_T Integrator_CSTATE;            /* '<S41>/Integrator' */\r\n  real_T x2WControlSimulink_PS_Converter[2];/* '<S60>/INPUT_1_1_1' */\r\n} X_x2WControl_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T x2WControlPrismatic_Joint1Pzp[4];/* '<S60>/STATE_1' */\r\n  real_T Filter_CSTATE;                /* '<S36>/Filter' */\r\n  real_T Integrator_CSTATE;            /* '<S41>/Integrator' */\r\n  real_T x2WControlSimulink_PS_Converter[2];/* '<S60>/INPUT_1_1_1' */\r\n} XDot_x2WControl_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T x2WControlPrismatic_Joint1Pzp[4];/* '<S60>/STATE_1' */\r\n  boolean_T Filter_CSTATE;             /* '<S36>/Filter' */\r\n  boolean_T Integrator_CSTATE;         /* '<S41>/Integrator' */\r\n  boolean_T x2WControlSimulink_PS_Converter[2];/* '<S60>/INPUT_1_1_1' */\r\n} XDis_x2WControl_T;\r\n\r\n#ifndef ODE3_INTG\r\n#define ODE3_INTG\r\n\r\n/* ODE3 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[3];                        /* derivatives */\r\n} ODE3_IntgData;\r\n\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\nstruct P_x2WControl_T_ {\r\n  real_T PIDController_D;              /* Mask Parameter: PIDController_D\r\n                                        * Referenced by: '<S35>/Derivative Gain'\r\n                                        */\r\n  real_T PIDController_I;              /* Mask Parameter: PIDController_I\r\n                                        * Referenced by: '<S38>/Integral Gain'\r\n                                        */\r\n  real_T PIDController_InitialConditionF;\r\n                              /* Mask Parameter: PIDController_InitialConditionF\r\n                               * Referenced by: '<S36>/Filter'\r\n                               */\r\n  real_T PIDController_InitialConditio_m;\r\n                              /* Mask Parameter: PIDController_InitialConditio_m\r\n                               * Referenced by: '<S41>/Integrator'\r\n                               */\r\n  real_T PIDController_N;              /* Mask Parameter: PIDController_N\r\n                                        * Referenced by: '<S44>/Filter Coefficient'\r\n                                        */\r\n  real_T PIDController_P;              /* Mask Parameter: PIDController_P\r\n                                        * Referenced by: '<S46>/Proportional Gain'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 180/pi\r\n                                        * Referenced by: '<Root>/Gain'\r\n                                        */\r\n  real_T Step_Time;                    /* Expression: 0.01\r\n                                        * Referenced by: '<Root>/Step'\r\n                                        */\r\n  real_T Step_Y0;                      /* Expression: 50\r\n                                        * Referenced by: '<Root>/Step'\r\n                                        */\r\n  real_T Step_YFinal;                  /* Expression: 0\r\n                                        * Referenced by: '<Root>/Step'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_x2WControl_T {\r\n  const char_T *errorStatus;\r\n  RTWLogInfo *rtwLogInfo;\r\n  RTWSolverInfo solverInfo;\r\n  X_x2WControl_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  XDis_x2WControl_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[8];\r\n  real_T odeF[3][8];\r\n  ODE3_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    time_T tFinal;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_x2WControl_T x2WControl_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_x2WControl_T x2WControl_B;\r\n\r\n/* Continuous states (default storage) */\r\nextern X_x2WControl_T x2WControl_X;\r\n\r\n/* Block states (default storage) */\r\nextern DW_x2WControl_T x2WControl_DW;\r\n\r\n/* Model entry point functions */\r\nextern void x2WControl_initialize(void);\r\nextern void x2WControl_step(void);\r\nextern void x2WControl_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_x2WControl_T *const x2WControl_M;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S58>/RESHAPE' : Reshape block reduction\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'x2WControl'\r\n * '<S1>'   : 'x2WControl/Cart'\r\n * '<S2>'   : 'x2WControl/Chassis'\r\n * '<S3>'   : 'x2WControl/PID Controller'\r\n * '<S4>'   : 'x2WControl/PS-Simulink Converter1'\r\n * '<S5>'   : 'x2WControl/Simulink-PS Converter1'\r\n * '<S6>'   : 'x2WControl/Solver Configuration'\r\n * '<S7>'   : 'x2WControl/Cart/Left Wheel '\r\n * '<S8>'   : 'x2WControl/Cart/Right Wheel'\r\n * '<S9>'   : 'x2WControl/Chassis/Rods'\r\n * '<S10>'  : 'x2WControl/PID Controller/Anti-windup'\r\n * '<S11>'  : 'x2WControl/PID Controller/D Gain'\r\n * '<S12>'  : 'x2WControl/PID Controller/Filter'\r\n * '<S13>'  : 'x2WControl/PID Controller/Filter ICs'\r\n * '<S14>'  : 'x2WControl/PID Controller/I Gain'\r\n * '<S15>'  : 'x2WControl/PID Controller/Ideal P Gain'\r\n * '<S16>'  : 'x2WControl/PID Controller/Ideal P Gain Fdbk'\r\n * '<S17>'  : 'x2WControl/PID Controller/Integrator'\r\n * '<S18>'  : 'x2WControl/PID Controller/Integrator ICs'\r\n * '<S19>'  : 'x2WControl/PID Controller/N Copy'\r\n * '<S20>'  : 'x2WControl/PID Controller/N Gain'\r\n * '<S21>'  : 'x2WControl/PID Controller/P Copy'\r\n * '<S22>'  : 'x2WControl/PID Controller/Parallel P Gain'\r\n * '<S23>'  : 'x2WControl/PID Controller/Reset Signal'\r\n * '<S24>'  : 'x2WControl/PID Controller/Saturation'\r\n * '<S25>'  : 'x2WControl/PID Controller/Saturation Fdbk'\r\n * '<S26>'  : 'x2WControl/PID Controller/Sum'\r\n * '<S27>'  : 'x2WControl/PID Controller/Sum Fdbk'\r\n * '<S28>'  : 'x2WControl/PID Controller/Tracking Mode'\r\n * '<S29>'  : 'x2WControl/PID Controller/Tracking Mode Sum'\r\n * '<S30>'  : 'x2WControl/PID Controller/Tsamp - Integral'\r\n * '<S31>'  : 'x2WControl/PID Controller/Tsamp - Ngain'\r\n * '<S32>'  : 'x2WControl/PID Controller/postSat Signal'\r\n * '<S33>'  : 'x2WControl/PID Controller/preSat Signal'\r\n * '<S34>'  : 'x2WControl/PID Controller/Anti-windup/Passthrough'\r\n * '<S35>'  : 'x2WControl/PID Controller/D Gain/Internal Parameters'\r\n * '<S36>'  : 'x2WControl/PID Controller/Filter/Cont. Filter'\r\n * '<S37>'  : 'x2WControl/PID Controller/Filter ICs/Internal IC - Filter'\r\n * '<S38>'  : 'x2WControl/PID Controller/I Gain/Internal Parameters'\r\n * '<S39>'  : 'x2WControl/PID Controller/Ideal P Gain/Passthrough'\r\n * '<S40>'  : 'x2WControl/PID Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S41>'  : 'x2WControl/PID Controller/Integrator/Continuous'\r\n * '<S42>'  : 'x2WControl/PID Controller/Integrator ICs/Internal IC'\r\n * '<S43>'  : 'x2WControl/PID Controller/N Copy/Disabled'\r\n * '<S44>'  : 'x2WControl/PID Controller/N Gain/Internal Parameters'\r\n * '<S45>'  : 'x2WControl/PID Controller/P Copy/Disabled'\r\n * '<S46>'  : 'x2WControl/PID Controller/Parallel P Gain/Internal Parameters'\r\n * '<S47>'  : 'x2WControl/PID Controller/Reset Signal/Disabled'\r\n * '<S48>'  : 'x2WControl/PID Controller/Saturation/Passthrough'\r\n * '<S49>'  : 'x2WControl/PID Controller/Saturation Fdbk/Disabled'\r\n * '<S50>'  : 'x2WControl/PID Controller/Sum/Sum_PID'\r\n * '<S51>'  : 'x2WControl/PID Controller/Sum Fdbk/Disabled'\r\n * '<S52>'  : 'x2WControl/PID Controller/Tracking Mode/Disabled'\r\n * '<S53>'  : 'x2WControl/PID Controller/Tracking Mode Sum/Passthrough'\r\n * '<S54>'  : 'x2WControl/PID Controller/Tsamp - Integral/TsSignalSpecification'\r\n * '<S55>'  : 'x2WControl/PID Controller/Tsamp - Ngain/Passthrough'\r\n * '<S56>'  : 'x2WControl/PID Controller/postSat Signal/Forward_Path'\r\n * '<S57>'  : 'x2WControl/PID Controller/preSat Signal/Forward_Path'\r\n * '<S58>'  : 'x2WControl/PS-Simulink Converter1/EVAL_KEY'\r\n * '<S59>'  : 'x2WControl/Simulink-PS Converter1/EVAL_KEY'\r\n * '<S60>'  : 'x2WControl/Solver Configuration/EVAL_KEY'\r\n */\r\n#endif                                 /* RTW_HEADER_x2WControl_h_ */\r\n"},{"name":"x2WControl_private.h","type":"header","group":"model","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * x2WControl_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_x2WControl_private_h_\r\n#define RTW_HEADER_x2WControl_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"x2WControl_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n/* private model entry point functions */\r\nextern void x2WControl_derivatives(void);\r\n\r\n#endif                                 /* RTW_HEADER_x2WControl_private_h_ */\r\n"},{"name":"x2WControl_types.h","type":"header","group":"model","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * x2WControl_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_x2WControl_types_h_\r\n#define RTW_HEADER_x2WControl_types_h_\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_x2WControl_T_ P_x2WControl_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_x2WControl_T RT_MODEL_x2WControl_T;\r\n\r\n#endif                                 /* RTW_HEADER_x2WControl_types_h_ */\r\n"},{"name":"x2WControl_data.c","type":"source","group":"data","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * x2WControl_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"x2WControl.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_x2WControl_T x2WControl_P = {\r\n  /* Mask Parameter: PIDController_D\r\n   * Referenced by: '<S35>/Derivative Gain'\r\n   */\r\n  0.01,\r\n\r\n  /* Mask Parameter: PIDController_I\r\n   * Referenced by: '<S38>/Integral Gain'\r\n   */\r\n  0.25,\r\n\r\n  /* Mask Parameter: PIDController_InitialConditionF\r\n   * Referenced by: '<S36>/Filter'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: PIDController_InitialConditio_m\r\n   * Referenced by: '<S41>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: PIDController_N\r\n   * Referenced by: '<S44>/Filter Coefficient'\r\n   */\r\n  100.0,\r\n\r\n  /* Mask Parameter: PIDController_P\r\n   * Referenced by: '<S46>/Proportional Gain'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<Root>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 0.01\r\n   * Referenced by: '<Root>/Step'\r\n   */\r\n  0.01,\r\n\r\n  /* Expression: 50\r\n   * Referenced by: '<Root>/Step'\r\n   */\r\n  50.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Step'\r\n   */\r\n  0.0\r\n};\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * builtin_typeid_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,\r\n  SS_SINGLE = 1,\r\n  SS_INT8 = 2,\r\n  SS_UINT8 = 3,\r\n  SS_INT16 = 4,\r\n  SS_UINT16 = 5,\r\n  SS_INT32 = 6,\r\n  SS_UINT32 = 7,\r\n  SS_BOOLEAN = 8\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int DTypeId;\r\n\r\n/* Enumeration of pre-defined data types */\r\ntypedef enum {\r\n  SS_FCN_CALL = 9,\r\n  SS_INTEGER = 10,\r\n  SS_POINTER = 11,\r\n  SS_INTERNAL_DTYPE2 = 12,\r\n  SS_TIMER_UINT32_PAIR = 13,\r\n  SS_CONNECTION_TYPE = 14\r\n} PreDefinedDTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} int288m_T;\r\n\r\ntypedef struct {\r\n  int288m_T re;\r\n  int288m_T im;\r\n} cint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} uint288m_T;\r\n\r\ntypedef struct {\r\n  uint288m_T re;\r\n  uint288m_T im;\r\n} cuint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} int352m_T;\r\n\r\ntypedef struct {\r\n  int352m_T re;\r\n  int352m_T im;\r\n} cint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} uint352m_T;\r\n\r\ntypedef struct {\r\n  uint352m_T re;\r\n  uint352m_T im;\r\n} cuint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} int416m_T;\r\n\r\ntypedef struct {\r\n  int416m_T re;\r\n  int416m_T im;\r\n} cint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} uint416m_T;\r\n\r\ntypedef struct {\r\n  uint416m_T re;\r\n  uint416m_T im;\r\n} cuint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} int480m_T;\r\n\r\ntypedef struct {\r\n  int480m_T re;\r\n  int480m_T im;\r\n} cint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} uint480m_T;\r\n\r\ntypedef struct {\r\n  uint480m_T re;\r\n  uint480m_T im;\r\n} cuint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} int544m_T;\r\n\r\ntypedef struct {\r\n  int544m_T re;\r\n  int544m_T im;\r\n} cint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} uint544m_T;\r\n\r\ntypedef struct {\r\n  uint544m_T re;\r\n  uint544m_T im;\r\n} cuint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} int608m_T;\r\n\r\ntypedef struct {\r\n  int608m_T re;\r\n  int608m_T im;\r\n} cint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} uint608m_T;\r\n\r\ntypedef struct {\r\n  uint608m_T re;\r\n  uint608m_T im;\r\n} cuint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} int672m_T;\r\n\r\ntypedef struct {\r\n  int672m_T re;\r\n  int672m_T im;\r\n} cint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} uint672m_T;\r\n\r\ntypedef struct {\r\n  uint672m_T re;\r\n  uint672m_T im;\r\n} cuint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} int736m_T;\r\n\r\ntypedef struct {\r\n  int736m_T re;\r\n  int736m_T im;\r\n} cint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} uint736m_T;\r\n\r\ntypedef struct {\r\n  uint736m_T re;\r\n  uint736m_T im;\r\n} cuint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} int800m_T;\r\n\r\ntypedef struct {\r\n  int800m_T re;\r\n  int800m_T im;\r\n} cint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} uint800m_T;\r\n\r\ntypedef struct {\r\n  uint800m_T re;\r\n  uint800m_T im;\r\n} cuint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} int864m_T;\r\n\r\ntypedef struct {\r\n  int864m_T re;\r\n  int864m_T im;\r\n} cint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} uint864m_T;\r\n\r\ntypedef struct {\r\n  uint864m_T re;\r\n  uint864m_T im;\r\n} cuint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} int928m_T;\r\n\r\ntypedef struct {\r\n  int928m_T re;\r\n  int928m_T im;\r\n} cint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} uint928m_T;\r\n\r\ntypedef struct {\r\n  uint928m_T re;\r\n  uint928m_T im;\r\n} cuint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} int992m_T;\r\n\r\ntypedef struct {\r\n  int992m_T re;\r\n  int992m_T im;\r\n} cint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} uint992m_T;\r\n\r\ntypedef struct {\r\n  uint992m_T re;\r\n  uint992m_T im;\r\n} cuint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} int1056m_T;\r\n\r\ntypedef struct {\r\n  int1056m_T re;\r\n  int1056m_T im;\r\n} cint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} uint1056m_T;\r\n\r\ntypedef struct {\r\n  uint1056m_T re;\r\n  uint1056m_T im;\r\n} cuint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} int1120m_T;\r\n\r\ntypedef struct {\r\n  int1120m_T re;\r\n  int1120m_T im;\r\n} cint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} uint1120m_T;\r\n\r\ntypedef struct {\r\n  uint1120m_T re;\r\n  uint1120m_T im;\r\n} cuint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} int1184m_T;\r\n\r\ntypedef struct {\r\n  int1184m_T re;\r\n  int1184m_T im;\r\n} cint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} uint1184m_T;\r\n\r\ntypedef struct {\r\n  uint1184m_T re;\r\n  uint1184m_T im;\r\n} cuint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} int1248m_T;\r\n\r\ntypedef struct {\r\n  int1248m_T re;\r\n  int1248m_T im;\r\n} cint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} uint1248m_T;\r\n\r\ntypedef struct {\r\n  uint1248m_T re;\r\n  uint1248m_T im;\r\n} cuint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} int1312m_T;\r\n\r\ntypedef struct {\r\n  int1312m_T re;\r\n  int1312m_T im;\r\n} cint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} uint1312m_T;\r\n\r\ntypedef struct {\r\n  uint1312m_T re;\r\n  uint1312m_T im;\r\n} cuint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} int1376m_T;\r\n\r\ntypedef struct {\r\n  int1376m_T re;\r\n  int1376m_T im;\r\n} cint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} uint1376m_T;\r\n\r\ntypedef struct {\r\n  uint1376m_T re;\r\n  uint1376m_T im;\r\n} cuint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} int1440m_T;\r\n\r\ntypedef struct {\r\n  int1440m_T re;\r\n  int1440m_T im;\r\n} cint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} uint1440m_T;\r\n\r\ntypedef struct {\r\n  uint1440m_T re;\r\n  uint1440m_T im;\r\n} cuint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} int1504m_T;\r\n\r\ntypedef struct {\r\n  int1504m_T re;\r\n  int1504m_T im;\r\n} cint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} uint1504m_T;\r\n\r\ntypedef struct {\r\n  uint1504m_T re;\r\n  uint1504m_T im;\r\n} cuint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} int1568m_T;\r\n\r\ntypedef struct {\r\n  int1568m_T re;\r\n  int1568m_T im;\r\n} cint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} uint1568m_T;\r\n\r\ntypedef struct {\r\n  uint1568m_T re;\r\n  uint1568m_T im;\r\n} cuint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} int1632m_T;\r\n\r\ntypedef struct {\r\n  int1632m_T re;\r\n  int1632m_T im;\r\n} cint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} uint1632m_T;\r\n\r\ntypedef struct {\r\n  uint1632m_T re;\r\n  uint1632m_T im;\r\n} cuint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} int1696m_T;\r\n\r\ntypedef struct {\r\n  int1696m_T re;\r\n  int1696m_T im;\r\n} cint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} uint1696m_T;\r\n\r\ntypedef struct {\r\n  uint1696m_T re;\r\n  uint1696m_T im;\r\n} cuint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} int1760m_T;\r\n\r\ntypedef struct {\r\n  int1760m_T re;\r\n  int1760m_T im;\r\n} cint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} uint1760m_T;\r\n\r\ntypedef struct {\r\n  uint1760m_T re;\r\n  uint1760m_T im;\r\n} cuint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} int1824m_T;\r\n\r\ntypedef struct {\r\n  int1824m_T re;\r\n  int1824m_T im;\r\n} cint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} uint1824m_T;\r\n\r\ntypedef struct {\r\n  uint1824m_T re;\r\n  uint1824m_T im;\r\n} cuint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} int1888m_T;\r\n\r\ntypedef struct {\r\n  int1888m_T re;\r\n  int1888m_T im;\r\n} cint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} uint1888m_T;\r\n\r\ntypedef struct {\r\n  uint1888m_T re;\r\n  uint1888m_T im;\r\n} cuint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} int1952m_T;\r\n\r\ntypedef struct {\r\n  int1952m_T re;\r\n  int1952m_T im;\r\n} cint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} uint1952m_T;\r\n\r\ntypedef struct {\r\n  uint1952m_T re;\r\n  uint1952m_T im;\r\n} cuint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} int2016m_T;\r\n\r\ntypedef struct {\r\n  int2016m_T re;\r\n  int2016m_T im;\r\n} cint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} uint2016m_T;\r\n\r\ntypedef struct {\r\n  uint2016m_T re;\r\n  uint2016m_T im;\r\n} cuint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"x2WControl\".\r\n *\r\n * Model version              : 1.9\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Mon May 29 16:02:07 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"x2WControl.h\"\r\n#define GRTINTERFACE                   0\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\n *\n * File: rt_backsubrr_dbl.c     \n *\n * Abstract:\n *      Simulink Coder support routine which performs\n *      backward substitution: solving Ux=b for real\n *      double precision float operands.\n *\n */\n\n#include \"rt_matrixlib.h\"\n\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\n * Abstract: Backward substitution: Solving Ux=b \n *           U: real, double\n *           b: real, double\n *           U is an upper (or unit upper) triangular full matrix.\n *           The entries in the lower triangle are ignored.\n *           U is a NxN matrix\n *           X is a NxP matrix\n *           B is a NxP matrix\n */\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\n                                   const real_T    *pb,\n                                   real_T          *x,\n                                   int_T            N,\n                                   int_T            P,\n                                   boolean_T        unit_upper)\n{\n  int_T i,k;\n  for(k=P; k>0; k--) {\n    real_T *pUcol = pU;\n    for(i=0; i<N; i++) {\n      real_T *xj = x + k*N-1;\n      real_T s = 0.0;\n      real_T *pUrow = pUcol--;          /* access current row of U */\n\n      {\n        int_T j = i;\n        while(j-- > 0) {\n          s += *pUrow * *xj--;\n          pUrow -= N;\n        }\n      }\n\n      if (unit_upper) {\n        *xj = *pb-- - s;\n      } else {\n        *xj = (*pb-- - s) / *pUrow;\n      }\n    }\n  }\n}\n\n/* [EOF] rt_backsubrr_dbl.c */\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\n *\n * File: rt_forwardsubrr_dbl.c     \n *\n * Abstract:\n *      Simulink Coder support routine which performs\n *      forward substitution: solving Lx=b\n *\n */\n\n#include \"rt_matrixlib.h\"\n\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\n * Abstract: Forward substitution: solving Lx=b \n *           L: Real, double\n *           b: Real, double\n *           L is a lower (or unit lower) triangular full matrix.\n *           The entries in the upper triangle are ignored.\n *           L is a NxN matrix\n *           X is a NxP matrix\n *           B is a NxP matrix\n */\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\n                                  const real_T  *pb,\n                                  real_T        *x,\n                                  int_T          N,\n                                  int_T          P,\n                                  const int32_T *piv,\n                                  boolean_T      unit_lower)\n{  \n  /* Real inputs: */\n  int_T i, k;\n  for(k=0; k<P; k++) {\n    real_T *pLcol = pL;\n    for(i=0; i<N; i++) {\n      real_T *xj = x + k*N;\n      real_T s = 0.0;\n      real_T *pLrow = pLcol++;          /* access current row of L */\n\n      {\n        int_T j = i;\n        while(j-- > 0) {\n          s += *pLrow * *xj;\n          pLrow += N;\n          xj++;\n        }\n      }\n\n      if (unit_lower) {\n        *xj = pb[piv[i]] - s;\n      } else {\n        *xj = (pb[piv[i]] - s) / *pLrow;\n      }\n    }\n    pb += N;\n  }\n}\n\n/* [EOF] rt_forwardsubrr_dbl.c */\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"},{"name":"rt_lu_real.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\n *\n * File: rt_lu_real.c     \n *\n * Abstract:\n *      Real-Time Workshop support routine for lu_real\n *\n */\n\n#include <math.h>\n#include \"rt_matrixlib.h\"\n\n/* Function: rt_lu_real  =======================================================\n * Abstract: A is real.\n *\n */\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\n                const int_T n,     /* number or rows = number of columns */\n                int32_T     *piv)  /* pivote vector                      */\n{\n  int_T k;\n\n  /* initialize row-pivot indices: */\n  for (k = 0; k < n; k++) {\n    piv[k] = k;\n  }\n\n  /* Loop over each column: */\n  for (k = 0; k < n; k++) {\n    const int_T kn = k*n;\n    int_T p = k;\n\n    /* Scan the lower triangular part of this column only\n     * Record row of largest value\n     */\n    {\n      int_T i;\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\n      for (i = k+1; i < n; i++) {\n        real_T q = fabs(A[i+kn]);\n        if (q > Amax) {p = i; Amax = q;}\n      }\n    }\n\n    /* swap rows if required */\n    if (p != k) {\n      int_T j;\n      int32_T t1;\n      for (j = 0; j < n; j++) {\n        real_T t;\n        const int_T j_n = j*n;\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\n      }\n      /* swap pivot row indices */\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\n    }\n\n    /* column reduction */\n    {\n      real_T Adiag = A[k+kn];\n      int_T i,j;\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\n\n        /* divide lower triangular part of column by max */\n        Adiag = 1.0/Adiag;\n        for (i = k+1; i < n; i++) {\n          A[i+kn] *= Adiag;\n        }\n\n        /* subtract multiple of column from remaining columns */\n        for (j = k+1; j < n; j++) {\n          int_T j_n = j*n;\n          for (i = k+1; i < n; i++) {\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\n          }\n        }\n      }\n    }\n  }\n}\n\n/* [EOF] rt_lu_real.c */\n"},{"name":"rt_matrixlib.h","type":"header","group":"other","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef rt_matrixlib_h\n#define rt_matrixlib_h\n\n/* Copyright 2007-2013 The MathWorks, Inc.\n *\n * File    : rt_matrixlib.h\n * Abstract:\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\n *\n */\n\n\n/*==========*\n * Includes *\n *==========*/\n\n#include \"rtwtypes.h\"\n#include <limits.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Matrix Multiplication Utility Functions */\nextern void rt_MatMultRR_Dbl(real_T         *y, \n                             const real_T   *A, \n                             const real_T   *B, \n                             const int_T dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultRC_Dbl(creal_T       *y,\n                             const real_T  *A,\n                             const creal_T *B,\n                             const int_T dims[3]);\n\nextern void rt_MatMultCR_Dbl(creal_T       *y,\n                             const creal_T *A,\n                             const real_T  *B,\n                             const int_T dims[3]);\n\nextern void rt_MatMultCC_Dbl(creal_T       *y,\n                             const creal_T *A,\n                             const creal_T *B,\n                             const int_T dims[3]);\n#endif\n\nextern void rt_MatMultRR_Sgl(real32_T       *y,\n                             const real32_T *A,\n                             const real32_T *B,\n                             const int_T  dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\n                             const real32_T  *A,\n                             const creal32_T *B,\n                             const int_T   dims[3]);\n\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\n                             const creal32_T *A,\n                             const real32_T  *B,\n                             const int_T   dims[3]);\n\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\n                             const creal32_T *A,\n                             const creal32_T *B,\n                             const int_T   dims[3]);\n#endif\n\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\n                                   const real_T *A,\n                                   const real_T *B,\n                                   const int_T dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\n                                   const real_T  *A,\n                                   const creal_T *B,\n                                   const int_T dims[3]);\n\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\n                                   const creal_T *A,\n                                   const real_T  *B,\n                                   const int_T dims[3]);\n\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\n                                   const creal_T *A,\n                                   const creal_T *B,\n                                   const int_T dims[3]);\n#endif\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\n                                   const real32_T *A,\n                                   const real32_T *B,\n                                   const int_T  dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\n                                   const real32_T  *A,\n                                   const creal32_T *B,\n                                   const int_T   dims[3]);\n\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\n                                   const creal32_T *A,\n                                   const real32_T  *B,\n                                   const int_T   dims[3]);\n\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\n                                   const creal32_T *A,\n                                   const creal32_T *B,\n                                   const int_T   dims[3]);\n#endif \n\n/* Matrix Inversion Utility Functions */\nextern void rt_lu_real(real_T      *A,\n                       const int_T n,\n                       int32_T     *piv);\n\n#ifdef CREAL_T\nextern void rt_lu_cplx(creal_T *A,\n                       const int_T n,\n                       int32_T *piv);\n#endif\n\nextern void rt_lu_real_sgl(real32_T      *A,\n                           const int_T n,\n                           int32_T     *piv);\n\n#ifdef CREAL_T\nextern void rt_lu_cplx_sgl(creal32_T *A,\n                           const int_T n,\n                           int32_T *piv);\n#endif\n\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\n                                          const real_T    *pb,\n                                          real_T          *x,\n                                          int_T            N,\n                                          int_T            P,\n                                          boolean_T        unit_upper);\n\n#ifdef CREAL_T\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\n                                          const creal_T   *pb,\n                                          creal_T         *x,\n                                          int_T            N,\n                                          int_T            P,\n                                          boolean_T        unit_upper);\n\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\n                                          const creal_T   *pb,\n                                          creal_T         *x,\n                                          int_T            N,\n                                          int_T            P,\n                                          boolean_T        unit_upper);\n#endif\n\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\n                                         const real_T  *pb,\n                                         real_T        *x,\n                                         int_T          N,\n                                         int_T          P,\n                                         const int32_T *piv,\n                                         boolean_T      unit_lower);\n\n#ifdef CREAL_T\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\n                                         const creal_T   *pb,\n                                         creal_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\n                                         const real_T    *pb,\n                                         creal_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\n                                         const creal_T   *pb,\n                                         creal_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n#endif\n\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\n                                          const real32_T    *pb,\n                                          real32_T          *x,\n                                          int_T              N,\n                                          int_T              P,\n                                          boolean_T          unit_upper);\n\n#ifdef CREAL_T\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\n                                          const creal32_T   *pb,\n                                          creal32_T         *x,\n                                          int_T              N,\n                                          int_T              P,\n                                          boolean_T          unit_upper);\n\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\n                                          const creal32_T   *pb,\n                                          creal32_T         *x,\n                                          int_T              N,\n                                          int_T              P,\n                                          boolean_T          unit_upper);\n#endif\n\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\n                                         const real32_T    *pb,\n                                         real32_T    *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\n#ifdef CREAL_T\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\n                                         const creal32_T   *pb,\n                                         creal32_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\n                                         const real32_T    *pb,\n                                         creal32_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\n                                         const creal32_T   *pb,\n                                         creal32_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n#endif\n\n\nextern void rt_MatDivRR_Dbl(real_T        *Out,\n                            const real_T  *In1,\n                            const real_T  *In2,\n                            real_T        *lu,\n                            int32_T       *piv,\n                            real_T        *x,\n                            const int_T    dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\n                            const real_T  *In1,\n                            const creal_T *In2,\n                            real_T        *lu,\n                            int32_T       *piv,\n                            creal_T       *x,\n                            const int_T    dims[3]);\n\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\n                            const creal_T *In1,\n                            const real_T  *In2,\n                            creal_T       *lu,\n                            int32_T       *piv,\n                            creal_T       *x,\n                            const int_T    dims[3]);\n\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\n                            const creal_T *In1,\n                            const creal_T *In2,\n                            creal_T       *lu,\n                            int32_T       *piv,\n                            creal_T       *x,\n                            const int_T    dims[3]);\n#endif\n\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\n                            const real32_T  *In1,\n                            const real32_T  *In2,\n                            real32_T        *lu,\n                            int32_T         *piv,\n                            real32_T        *x,\n                            const int_T      dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\n                            const real32_T  *In1,\n                            const creal32_T *In2,\n                            real32_T        *lu,\n                            int32_T         *piv,\n                            creal32_T       *x,\n                            const int_T      dims[3]);\n\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\n                            const creal32_T *In1,\n                            const real32_T  *In2,\n                            creal32_T       *lu,\n                            int32_T         *piv,\n                            creal32_T       *x,\n                            const int_T      dims[3]);\n\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\n                            const creal32_T *In1,\n                            const creal32_T *In2,\n                            creal32_T       *lu,\n                            int32_T         *piv,\n                            creal32_T       *x,\n                            const int_T      dims[3]);\n#endif\n\n\n/* Matrix multiplication defines */\n\n/* Quick (approximate) complex absolute value: */\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\n\n/* Quick (approximate) complex absolute value for singles: */\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \n\n#ifdef CREAL_T\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\n                                const creal_T In1,\n                                const creal_T In2);\n\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\n                                  const creal_T In1,\n                                  const creal_T In2);\n\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\n                                     const creal_T In1);\n\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\n                                const creal32_T In1,\n                                const creal32_T In2);\n\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\n                                  const creal32_T In1,\n                                  const creal32_T In2);\n\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\n                                     const creal32_T In1);\n\n#endif\n\nextern real_T rt_Hypot_Dbl(real_T In1,\n                           real_T In2);\n\nextern real32_T rt_Hypot_Sgl(real32_T In1,\n                             real32_T In2);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* rt_matrixlib_h */\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\n *\n * File: rt_matrixlib_dbl.c\n *\n * Abstract:\n *      Simulink Coder utility functions\n *\n */\n\n#include <math.h>\n#include \"rt_matrixlib.h\"\n\n#ifdef CREAL_T\nvoid rt_ComplexTimes_Dbl(creal_T* c,\n                         const creal_T a,\n                         const creal_T b)\n{\n    if (a.im == 0.0) {\n        c->re = a.re * b.re;\n        c->im = a.re * b.im;\n        if (b.im == 0.0) {\n            c->im = 0.0;\n        } else if (b.re == 0.0 || a.re == 0.0) {\n            c->re = 0.0;\n        }\n    } else if (b.im == 0.0) {\n        c->re = a.re * b.re;\n        c->im = a.im * b.re;\n        if (b.re == 0.0 || a.re == 0.0) { \n            c->re = 0.0;\n        }\n    } else if (a.re == 0.0) {\n        c->re = -a.im * b.im;\n        c->im = a.im * b.re;\n        if (b.re == 0.0) {\n            c->im = 0.0;\n        }\n    } else if (b.re == 0.0) {\n        c->re = -a.im * b.im;\n        c->im = a.re * b.im;\n    } else {\n        c->re = a.re * b.re - a.im * b.im;\n        c->im = a.re * b.im + a.im * b.re;\n    }\n}\n\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\n                           const creal_T a,\n                           const creal_T b)\n{\n    if (b.im == 0.0) {\n        c->re = a.re / b.re;\n        if (a.im == 0.0) {\n            c->im = 0.0;\n        } else { /* a.im != 0.0 */\n            c->im = a.im / b.re;\n            if (a.re == 0.0) {\n                c->re = 0.0;\n            }\n        }\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\n        c->re = a.im / b.im;\n        c->im = -a.re / b.im;\n        if (a.re == 0.0) {\n            c->im = 0.0;\n        } else if (a.im == 0.0) {\n            c->re = 0.0;\n        }\n    } else {\n        real_T brm = fabs(b.re);\n        real_T bim = fabs(b.im);\n        if (brm > bim) {\n            real_T s = b.im / b.re;\n            real_T d = b.re + s * b.im;\n            c->im = (a.im - s * a.re) / d;\n            c->re = (a.re + s * a.im) / d;\n        } else if (brm == bim) {\n            real_T half = 0.5;\n            real_T sgnbr = b.re > 0.0 ? half : -half;\n            real_T sgnbi = b.im > 0.0 ? half : -half;\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\n        } else {\n            real_T s = b.re / b.im;\n            real_T d = b.im + s * b.re;\n            c->im = (s * a.im - a.re) / d;\n            c->re = (s * a.re + a.im) / d;\n        }\n    }\n}\n\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\n                              const creal_T In1)\n{\n    creal_T y;\n    y.re = 1.0;\n    y.im = 0.0;\n\n    rt_ComplexRDivide_Dbl(Out, y, In1);\n}\n\n#endif\n\n\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\n{\n    real_T y;\n    if (a != a || b != b) {\n        y = a + b;\n    } else {\n        real_T t;\n        if (fabs(a) > fabs(b)) {\n            t = b/a;\n            y = fabs(a)*sqrt(1.0 + t*t);\n        } else {\n            if (b == 0.0) {\n                y = 0.0;\n            } else {\n                t = a/b;\n                y = fabs(b)*sqrt(1.0 + t*t);\n            }\n        }\n    }\n    \n    return y;\n}\n"},{"name":"ssc_ml_fun.h","type":"header","group":"other","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n#ifndef SSC_ML_FUN_H\r\n#define SSC_ML_FUN_H                   1\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n;\r\n\r\n#endif\r\n"},{"name":"x2WControl_a151ee3d_1.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_std.h\"\r\n#include \"pm_default_allocator.h\"\r\n#include \"ne_dae.h\"\r\n#include \"ne_solverparameters.h\"\r\n#include \"sm_ssci_NeDaePrivateData.h\"\r\n\r\nNeDae *sm_ssci_constructDae(NeDaePrivateData *smData);\r\nvoid x2WControl_a151ee3d_1_NeDaePrivateData_create(NeDaePrivateData *smData);\r\nvoid x2WControl_a151ee3d_1_dae(\r\n  NeDae **dae,\r\n  const NeModelParameters *modelParams,\r\n  const NeSolverParameters *solverParams)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  NeDaePrivateData *smData =\r\n    (NeDaePrivateData *) alloc->mCallocFcn(alloc, sizeof(NeDaePrivateData), 1);\r\n  (void) modelParams;\r\n  (void) solverParams;\r\n  x2WControl_a151ee3d_1_NeDaePrivateData_create(smData);\r\n  *dae = sm_ssci_constructDae(smData);\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1.h","type":"header","group":"other","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#ifndef __x2WControl_a151ee3d_1_h__\r\n#define __x2WControl_a151ee3d_1_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern void x2WControl_a151ee3d_1_dae( NeDae **dae, const NeModelParameters\r\n    *modelParams,\r\n    const NeSolverParameters *solverParams);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n#endif\r\n"},{"name":"x2WControl_a151ee3d_1_asm_delegate.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n#include \"sm_CTarget.h\"\r\n\r\nvoid x2WControl_a151ee3d_1_setTargets(const RuntimeDerivedValuesBundle *rtdv,\r\n  CTarget *targets)\r\n{\r\n  (void) rtdv;\r\n  (void) targets;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_resetAsmStateVector(const void *mech, double *state)\r\n{\r\n  double xx[1];\r\n  (void) mech;\r\n  xx[0] = 0.0;\r\n  state[0] = xx[0];\r\n  state[1] = xx[0];\r\n  state[2] = xx[0];\r\n  state[3] = xx[0];\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_initializeTrackedAngleState(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const int *modeVector, const double\r\n  *motionData, double *state)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) state;\r\n  (void) modeVector;\r\n  (void) motionData;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeDiscreteState(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, double *state)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) state;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_adjustPosition(const void *mech, const double\r\n  *dofDeltas, double *state)\r\n{\r\n  (void) mech;\r\n  state[0] = state[0] + dofDeltas[0];\r\n  state[2] = state[2] + dofDeltas[1];\r\n}\r\n\r\nstatic void perturbAsmJointPrimitiveState_0_0(double mag, double *state)\r\n{\r\n  state[0] = state[0] + mag;\r\n}\r\n\r\nstatic void perturbAsmJointPrimitiveState_0_0v(double mag, double *state)\r\n{\r\n  state[0] = state[0] + mag;\r\n  state[1] = state[1] - 0.875 * mag;\r\n}\r\n\r\nstatic void perturbAsmJointPrimitiveState_1_0(double mag, double *state)\r\n{\r\n  state[2] = state[2] + mag;\r\n}\r\n\r\nstatic void perturbAsmJointPrimitiveState_1_0v(double mag, double *state)\r\n{\r\n  state[2] = state[2] + mag;\r\n  state[3] = state[3] - 0.875 * mag;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_perturbAsmJointPrimitiveState(const void *mech,\r\n  size_t stageIdx, size_t primIdx, double mag, boolean_T doPerturbVelocity,\r\n  double *state)\r\n{\r\n  (void) mech;\r\n  (void) stageIdx;\r\n  (void) primIdx;\r\n  (void) mag;\r\n  (void) doPerturbVelocity;\r\n  (void) state;\r\n  switch ((stageIdx * 6 + primIdx) * 2 + (doPerturbVelocity ? 1 : 0))\r\n  {\r\n   case 0:\r\n    perturbAsmJointPrimitiveState_0_0(mag, state);\r\n    break;\r\n\r\n   case 1:\r\n    perturbAsmJointPrimitiveState_0_0v(mag, state);\r\n    break;\r\n\r\n   case 12:\r\n    perturbAsmJointPrimitiveState_1_0(mag, state);\r\n    break;\r\n\r\n   case 13:\r\n    perturbAsmJointPrimitiveState_1_0v(mag, state);\r\n    break;\r\n  }\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computePosDofBlendMatrix(const void *mech, size_t\r\n  stageIdx, size_t primIdx, const double *state, int partialType, double *matrix)\r\n{\r\n  (void) mech;\r\n  (void) stageIdx;\r\n  (void) primIdx;\r\n  (void) state;\r\n  (void) partialType;\r\n  (void) matrix;\r\n  switch ((stageIdx * 6 + primIdx))\r\n  {\r\n  }\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeVelDofBlendMatrix(const void *mech, size_t\r\n  stageIdx, size_t primIdx, const double *state, int partialType, double *matrix)\r\n{\r\n  (void) mech;\r\n  (void) stageIdx;\r\n  (void) primIdx;\r\n  (void) state;\r\n  (void) partialType;\r\n  (void) matrix;\r\n  switch ((stageIdx * 6 + primIdx))\r\n  {\r\n  }\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_projectPartiallyTargetedPos(const void *mech, size_t\r\n  stageIdx, size_t primIdx, const double *origState, int partialType, double\r\n  *state)\r\n{\r\n  (void) mech;\r\n  (void) stageIdx;\r\n  (void) primIdx;\r\n  (void) origState;\r\n  (void) partialType;\r\n  (void) state;\r\n  switch ((stageIdx * 6 + primIdx))\r\n  {\r\n  }\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_propagateMotion(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const double *state, double *motionData)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  double xx[18];\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  xx[0] = 0.7071067811865476;\r\n  xx[1] = 0.0;\r\n  xx[2] = 0.7070996124424118;\r\n  xx[3] = 0.5 * state[2];\r\n  xx[4] = cos(xx[3]);\r\n  xx[5] = 3.184035771019137e-3;\r\n  xx[6] = sin(xx[3]);\r\n  xx[3] = xx[2] * xx[4] - xx[5] * xx[6];\r\n  xx[7] = xx[2] * xx[6];\r\n  xx[2] = xx[5] * xx[4];\r\n  xx[4] = xx[7] + xx[2];\r\n  xx[5] = xx[2] + xx[7];\r\n  xx[2] = 4.741612338356591e-3;\r\n  xx[6] = xx[4] * xx[2];\r\n  xx[7] = 7.996472092178833e-3;\r\n  xx[8] = xx[2] * xx[3] - xx[5] * xx[7];\r\n  xx[9] = xx[4] * xx[7];\r\n  xx[10] = - xx[6];\r\n  xx[11] = xx[8];\r\n  xx[12] = xx[9];\r\n  pm_math_Vector3_cross_ra(xx + 3, xx + 10, xx + 13);\r\n  xx[10] = 2.0;\r\n  xx[11] = xx[4] * state[1];\r\n  xx[12] = xx[5] * state[1];\r\n  xx[16] = xx[12] * xx[3];\r\n  xx[17] = xx[11] * xx[3];\r\n  motionData[0] = xx[0];\r\n  motionData[1] = xx[1];\r\n  motionData[2] = xx[0];\r\n  motionData[3] = xx[1];\r\n  motionData[4] = xx[1];\r\n  motionData[5] = xx[1];\r\n  motionData[6] = state[0];\r\n  motionData[7] = xx[3];\r\n  motionData[8] = xx[3];\r\n  motionData[9] = xx[4];\r\n  motionData[10] = xx[5];\r\n  motionData[11] = - ((xx[13] - xx[6] * xx[3]) * xx[10] - xx[7]);\r\n  motionData[12] = - ((xx[3] * xx[8] + xx[14]) * xx[10]);\r\n  motionData[13] = - (xx[10] * (xx[15] + xx[9] * xx[3]) - xx[2]);\r\n  motionData[14] = xx[1];\r\n  motionData[15] = xx[1];\r\n  motionData[16] = xx[1];\r\n  motionData[17] = - state[1];\r\n  motionData[18] = xx[1];\r\n  motionData[19] = xx[1];\r\n  motionData[20] = xx[1];\r\n  motionData[21] = state[3];\r\n  motionData[22] = xx[1];\r\n  motionData[23] = (xx[4] * xx[11] + xx[5] * xx[12]) * xx[10] - state[1] +\r\n    4.741612338356592e-3 * state[3];\r\n  motionData[24] = xx[10] * (xx[16] - xx[17]);\r\n  motionData[25] = - (7.996472092178835e-3 * state[3] + (xx[17] + xx[16]) * xx\r\n                      [10]);\r\n}\r\n\r\nsize_t x2WControl_a151ee3d_1_computeAssemblyError(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, size_t constraintIdx, const int *modeVector,\r\n  const double *motionData, double *error)\r\n{\r\n  (void) mech;\r\n  (void)rtdv;\r\n  (void) modeVector;\r\n  (void) motionData;\r\n  (void) error;\r\n  switch (constraintIdx)\r\n  {\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nsize_t x2WControl_a151ee3d_1_computeAssemblyJacobian(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, size_t constraintIdx, boolean_T\r\n  forVelocitySatisfaction, const double *state, const int *modeVector, const\r\n  double *motionData, double *J)\r\n{\r\n  (void) mech;\r\n  (void) rtdv;\r\n  (void) state;\r\n  (void) modeVector;\r\n  (void) forVelocitySatisfaction;\r\n  (void) motionData;\r\n  (void) J;\r\n  switch (constraintIdx)\r\n  {\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nsize_t x2WControl_a151ee3d_1_computeFullAssemblyJacobian(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const int *modeVector,\r\n  const double *motionData, double *J)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) state;\r\n  (void) modeVector;\r\n  (void) motionData;\r\n  (void) J;\r\n  return 0;\r\n}\r\n\r\nboolean_T x2WControl_a151ee3d_1_isInKinematicSingularity(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, size_t constraintIdx, const int *modeVector,\r\n  const double *motionData)\r\n{\r\n  (void) mech;\r\n  (void) rtdv;\r\n  (void) modeVector;\r\n  (void) motionData;\r\n  switch (constraintIdx)\r\n  {\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_convertStateVector(const void *asmMech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const void *simMech, const double *asmState,\r\n  const int *asmModeVector, const int *simModeVector, double *simState)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) asmMech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) simMech;\r\n  (void) asmModeVector;\r\n  (void) simModeVector;\r\n  simState[0] = asmState[0];\r\n  simState[1] = asmState[1];\r\n  simState[2] = asmState[2];\r\n  simState[3] = asmState[3];\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_asserts.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n\r\nvoid x2WControl_a151ee3d_1_validateRuntimeParameters(const double *rtp, int32_T *\r\n  satFlags)\r\n{\r\n  (void) rtp;\r\n  (void) satFlags;\r\n}\r\n\r\nconst NeAssertData *x2WControl_a151ee3d_1_assertData = NULL;\r\n"},{"name":"x2WControl_a151ee3d_1_checkDynamics.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n#include \"x2WControl_a151ee3d_1_geometries.h\"\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_checkDynamics(const\r\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const double *input,\r\n  const double *inputDot, const double *inputDdot, const double *discreteState,\r\n  const int *modeVector, double *errorResult, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) state;\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) discreteState;\r\n  (void) modeVector;\r\n  (void) neDiagMgr;\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_compOutputs.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n#include \"x2WControl_a151ee3d_1_geometries.h\"\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_compOutputs(const RuntimeDerivedValuesBundle *\r\n  rtdv, const double *state, const int *modeVector, const double *input, const\r\n  double *inputDot, const double *inputDdot, const double *discreteState, double\r\n  *output, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) modeVector;\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) discreteState;\r\n  (void) neDiagMgr;\r\n  output[0] = state[2];\r\n  return NULL;\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_create.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include \"pm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"pm_default_allocator.h\"\r\n#include \"sm_ssci_NeDaePrivateData.h\"\r\n#include \"sm_CTarget.h\"\r\n\r\nPmfMessageId sm_ssci_recordRunTimeError(\r\n  const char *errorId, const char *errorMsg, NeuDiagnosticManager* mgr);\r\n\r\n#define pm_allocator_alloc(_allocator, _m, _n) ((_allocator)->mCallocFcn((_allocator), (_m), (_n)))\r\n#define PM_ALLOCATE_ARRAY(_name, _type, _size, _allocator)\\\r\n _name = (_type *) pm_allocator_alloc(_allocator, sizeof(_type), _size)\r\n#define pm_size_to_int(_size)          ((int32_T) (_size))\r\n\r\nPmIntVector *pm_create_int_vector(size_t, PmAllocator *);\r\nint_T pm_create_int_vector_fields (PmIntVector *, size_t, PmAllocator *);\r\nint_T pm_create_real_vector_fields(PmRealVector *, size_t, PmAllocator *);\r\nint_T pm_create_char_vector_fields(PmCharVector *, size_t, PmAllocator *);\r\nint_T pm_create_bool_vector_fields(PmBoolVector *, size_t, PmAllocator *);\r\nvoid pm_rv_equals_rv(const PmRealVector *, const PmRealVector *);\r\nextern const NeAssertData x2WControl_a151ee3d_1_assertData[];\r\nextern const NeZCData x2WControl_a151ee3d_1_ZCData[];\r\nvoid x2WControl_a151ee3d_1_computeRuntimeParameters(\r\n  const double *runtimeRootVariables,\r\n  double *runtimeParameters);\r\nvoid x2WControl_a151ee3d_1_validateRuntimeParameters(\r\n  const double *runtimeParameters,\r\n  int32_T *assertSatisfactionFlags);\r\nvoid x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValues(\r\n  const double *runtimeParameters,\r\n  RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle);\r\nvoid x2WControl_a151ee3d_1_computeSimRuntimeDerivedValues(\r\n  const double *runtimeParameters,\r\n  RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle);\r\nvoid x2WControl_a151ee3d_1_initializeGeometries(\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle);\r\nPmfMessageId x2WControl_a151ee3d_1_compDerivs(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const int *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_numJacPerturbLoBounds(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const int *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_numJacPerturbHiBounds(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const int *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_checkDynamics(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const double *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  const int *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_compOutputsDyn(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const int *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  double *,\r\n  int *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_compOutputsKin(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_compOutputs (\r\n  const RuntimeDerivedValuesBundle *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_computeAsmModeVector(\r\n  const double *, const double *, const double *,\r\n  int *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_computeSimModeVector(\r\n  const double *, const double *, const double *,\r\n  int *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_computeZeroCrossings(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const double *,\r\n  const double *, const double *, const double *,\r\n  const double *,\r\n  double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nPmfMessageId x2WControl_a151ee3d_1_recordLog(\r\n  const RuntimeDerivedValuesBundle *,\r\n  const int *,\r\n  const double *,\r\n  const int *,\r\n  const double *, const double *, const double *,\r\n  double *,\r\n  double *,\r\n  NeuDiagnosticManager *neDiagMgr);\r\nvoid x2WControl_a151ee3d_1_setTargets(\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  CTarget *targets);\r\nvoid x2WControl_a151ee3d_1_resetAsmStateVector(const void *mech, double\r\n  *stateVector);\r\nvoid x2WControl_a151ee3d_1_resetSimStateVector(const void *mech, double\r\n  *stateVector);\r\nvoid x2WControl_a151ee3d_1_initializeTrackedAngleState(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const int *modeVector,\r\n  const double *motionData,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_computeDiscreteState(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_adjustPosition(\r\n  const void *mech,\r\n  const double *dofDeltas,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_perturbAsmJointPrimitiveState(\r\n  const void *mech,\r\n  size_t stageIdx,\r\n  size_t primitiveIdx,\r\n  double magnitude,\r\n  boolean_T doPerturbVelocity,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_perturbSimJointPrimitiveState(\r\n  const void *mech,\r\n  size_t stageIdx,\r\n  size_t primitiveIdx,\r\n  double magnitude,\r\n  boolean_T doPerturbVelocity,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_perturbFlexibleBodyState(\r\n  const void *mech,\r\n  size_t stageIdx,\r\n  double magnitude,\r\n  boolean_T doPerturbVelocity,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_computePosDofBlendMatrix(\r\n  const void *mech,\r\n  size_t stageIdx,\r\n  size_t primitiveIdx,\r\n  const double *stateVector,\r\n  int partialType,\r\n  double *matrix);\r\nvoid x2WControl_a151ee3d_1_computeVelDofBlendMatrix(\r\n  const void *mech,\r\n  size_t stageIdx,\r\n  size_t primitiveIdx,\r\n  const double *stateVector,\r\n  int partialType,\r\n  double *matrix);\r\nvoid x2WControl_a151ee3d_1_projectPartiallyTargetedPos(\r\n  const void *mech,\r\n  size_t stageIdx,\r\n  size_t primitiveIdx,\r\n  const double *origStateVector,\r\n  int partialType,\r\n  double *stateVector);\r\nvoid x2WControl_a151ee3d_1_propagateMotion(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const double *stateVector,\r\n  double *motionData);\r\nsize_t x2WControl_a151ee3d_1_computeAssemblyError(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  size_t constraintIdx,\r\n  const int *modeVector,\r\n  const double *motionData,\r\n  double *error);\r\nsize_t x2WControl_a151ee3d_1_computeAssemblyJacobian(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  size_t constraintIdx,\r\n  boolean_T forVelocitySatisfaction,\r\n  const double *stateVector,\r\n  const int *modeVector,\r\n  const double *motionData,\r\n  double *J);\r\nsize_t x2WControl_a151ee3d_1_computeFullAssemblyJacobian(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const double *stateVector,\r\n  const int *modeVector,\r\n  const double *motionData,\r\n  double *J);\r\nboolean_T x2WControl_a151ee3d_1_isInKinematicSingularity(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  size_t constraintIdx,\r\n  const int *modeVector,\r\n  const double *motionData);\r\nvoid x2WControl_a151ee3d_1_convertStateVector(\r\n  const void *asmMech,\r\n  const RuntimeDerivedValuesBundle *asmRuntimeDerivedValuesBundle,\r\n  const void *simMech,\r\n  const double *asmStateVector,\r\n  const int *asmModeVector,\r\n  const int *simModeVector,\r\n  double *simStateVector);\r\nvoid x2WControl_a151ee3d_1_constructStateVector(\r\n  const void *mech,\r\n  const double *solverStateVector,\r\n  const double *u,\r\n  const double *uDot,\r\n  const double *discreteStateVector,\r\n  double *fullStateVector);\r\nvoid x2WControl_a151ee3d_1_extractSolverStateVector(\r\n  const void *mech,\r\n  const double *fullStateVector,\r\n  double *solverStateVector);\r\nboolean_T x2WControl_a151ee3d_1_isPositionViolation(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const int *constraintEqnEnableFlags,\r\n  const double *stateVector,\r\n  const int *modeVector);\r\nboolean_T x2WControl_a151ee3d_1_isVelocityViolation(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const int *constraintEqnEnableFlags,\r\n  const double *stateVector,\r\n  const int *modeVector);\r\nPmfMessageId x2WControl_a151ee3d_1_projectStateSim(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const int *constraintEqnEnableFlags,\r\n  const int *modeVector,\r\n  double *stateVector,\r\n  void *neDiagMgr);\r\nvoid x2WControl_a151ee3d_1_computeConstraintError(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const double *stateVector,\r\n  const int *modeVector,\r\n  double *error);\r\nvoid x2WControl_a151ee3d_1_resetModeVector(const void *mech, int *modeVector);\r\nboolean_T x2WControl_a151ee3d_1_hasJointDisToNormModeChange(\r\n  const void *mech,\r\n  const int *prevModeVector,\r\n  const int *modeVector);\r\nPmfMessageId x2WControl_a151ee3d_1_performJointDisToNormModeChange(\r\n  const void *mech,\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\r\n  const int *constraintEqnEnableFlags,\r\n  const int *prevModeVector,\r\n  const int *modeVector,\r\n  const double *inputVector,\r\n  double *stateVector,\r\n  void *neDiagMgr);\r\nvoid x2WControl_a151ee3d_1_onModeChangedCutJoints(\r\n  const void *mech,\r\n  const int *prevModeVector,\r\n  const int *modeVector,\r\n  double *stateVector);\r\nPmfMessageId x2WControl_a151ee3d_1_assemble(const double *u, double *udot,\r\n  double *x,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  (void) x;\r\n  (void) u;\r\n  (void) udot;\r\n  (void) neDiagMgr;\r\n  return NULL;\r\n}\r\n\r\nstatic\r\n  void dae_cg_setParameters_function(const NeDae *dae,\r\n  const NeParameterBundle *paramBundle)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  const double *runtimeRootVariables = paramBundle->mRealParameters.mX;\r\n  if (smData->mRuntimeParameterScalars.mN == 0)\r\n    return;\r\n  x2WControl_a151ee3d_1_computeRuntimeParameters(\r\n    runtimeRootVariables,\r\n    smData->mRuntimeParameterScalars.mX);\r\n  x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValues(\r\n    smData->mRuntimeParameterScalars.mX,\r\n    &dae->mPrivateData->mAsmRuntimeDerivedValuesBundle);\r\n  x2WControl_a151ee3d_1_computeSimRuntimeDerivedValues(\r\n    smData->mRuntimeParameterScalars.mX,\r\n    &dae->mPrivateData->mSimRuntimeDerivedValuesBundle);\r\n  x2WControl_a151ee3d_1_initializeGeometries\r\n    (&smData->mSimRuntimeDerivedValuesBundle);\r\n  sm_core_computeRedundantConstraintEquations(\r\n    &dae->mPrivateData->mSimulationDelegate,\r\n    &smData->mSimRuntimeDerivedValuesBundle);\r\n\r\n#if 0\r\n\r\n  {\r\n    size_t i;\r\n    const size_t n = smData->mSimulationDelegate.mRunTimeEnabledEquations.mSize;\r\n    pmf_printf(\"\\nRuntime Enabled Equations (%lu)\\n\", n);\r\n    for (i = 0; i < n; ++i)\r\n      pmf_printf(\"  %2lu:  %d\\n\", i,\r\n                 smData->mSimulationDelegate.mRunTimeEnabledEquations.mValues[i]);\r\n  }\r\n\r\n#endif\r\n\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_pAssert_method(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  const double *runtimeParams = smData->mRuntimeParameterScalars.mX;\r\n  int32_T *assertSatisfactionFlags = daeMethodOutput->mPASSERT.mX;\r\n  (void) systemInput;\r\n  (void) neDiagMgr;\r\n  x2WControl_a151ee3d_1_validateRuntimeParameters(\r\n    runtimeParams, assertSatisfactionFlags);\r\n  return NULL;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_deriv_method(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  double errorResult = 0.0;\r\n  if (smData->mCachedDerivativesAvailable)\r\n    memcpy(daeMethodOutput->mXP0.mX, smData->mCachedDerivatives.mX,\r\n           4 * sizeof(real_T));\r\n  else\r\n    errorId = x2WControl_a151ee3d_1_compDerivs(\r\n      &smData->mSimRuntimeDerivedValuesBundle,\r\n      smData->mSimulationDelegate\r\n      .mRunTimeEnabledEquations.mValues,\r\n      systemInput->mX.mX,\r\n      systemInput->mM.mX,\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mV.mX + 1,\r\n      systemInput->mD.mX,\r\n      daeMethodOutput->mXP0.mX,\r\n      &errorResult,\r\n      neDiagMgr);\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_numJacPerturbLoBounds_method(\r\n  const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  double errorResult = 0.0;\r\n  errorId = x2WControl_a151ee3d_1_numJacPerturbLoBounds(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    smData->mSimulationDelegate\r\n    .mRunTimeEnabledEquations.mValues,\r\n    systemInput->mX.mX,\r\n    systemInput->mM.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mV.mX + 1,\r\n    systemInput->mD.mX,\r\n    daeMethodOutput->mNUMJAC_DX_LO.mX,\r\n    &errorResult,\r\n    neDiagMgr);\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_numJacPerturbHiBounds_method(\r\n  const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  double errorResult = 0.0;\r\n  errorId = x2WControl_a151ee3d_1_numJacPerturbHiBounds(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    smData->mSimulationDelegate\r\n    .mRunTimeEnabledEquations.mValues,\r\n    systemInput->mX.mX,\r\n    systemInput->mM.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mV.mX + 1,\r\n    systemInput->mD.mX,\r\n    daeMethodOutput->mNUMJAC_DX_HI.mX,\r\n    &errorResult,\r\n    neDiagMgr);\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_compOutputs_method(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  PmfMessageId errorId = NULL;\r\n  NeDaePrivateData *smData = dae->mPrivateData;\r\n  errorId = x2WControl_a151ee3d_1_compOutputs(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    systemInput->mX.mX,\r\n    systemInput->mM.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mV.mX + 1,\r\n    systemInput->mD.mX,\r\n    daeMethodOutput->mY.mX, neDiagMgr);\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_mode_method(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  double errorResult = 0.0;\r\n  errorId = x2WControl_a151ee3d_1_computeSimModeVector(\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mV.mX + 1,\r\n    daeMethodOutput->mMODE.mX,\r\n    &errorResult,\r\n    neDiagMgr);\r\n  memcpy(smData->mCachedModeVector.mX, daeMethodOutput->mMODE.mX,\r\n         0 * sizeof(int32_T));\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_zeroCrossing_method(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeDaeMethodOutput *daeMethodOutput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  double errorResult = 0.0;\r\n  return\r\n    x2WControl_a151ee3d_1_computeZeroCrossings(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    systemInput->mX.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mV.mX + 1,\r\n    systemInput->mD.mX,\r\n    daeMethodOutput->mZC.mX,\r\n    &errorResult,\r\n    neDiagMgr);\r\n}\r\n\r\nstatic\r\n  void dae_cg_setupLoggerFcn(const NeDae *dae,\r\n  NeLoggerBuilder *neLoggerBuilder)\r\n{\r\n  (void) dae;\r\n  (void) neLoggerBuilder;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_recordLog_method(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  PmRealVector *output,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  double errorResult = 0.0;\r\n  double *fullStateVector = smData->mSimulationFullStateVector.mX;\r\n  x2WControl_a151ee3d_1_constructStateVector(\r\n    NULL,\r\n    systemInput->mX.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mD.mX,\r\n    fullStateVector);\r\n  errorId = x2WControl_a151ee3d_1_recordLog(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    smData->mSimulationDelegate\r\n    .mRunTimeEnabledEquations.mValues,\r\n    fullStateVector,\r\n    systemInput->mM.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mV.mX + 1,\r\n    output->mX,\r\n    &errorResult,\r\n    neDiagMgr);\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_project_solve(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  NeDaePrivateData *smData = dae->mPrivateData;\r\n  return\r\n    sm_core_projectState(\r\n    false,\r\n    &smData->mSimulationDelegate,\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    systemInput->mM.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mD.mX,\r\n    systemInput->mX.mX, neDiagMgr);\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_check_solve(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  if (smData->mNumConstraintEqns > 0)\r\n    errorId = sm_core_projectState(\r\n      false,\r\n      &smData->mSimulationDelegate,\r\n      &smData->mSimRuntimeDerivedValuesBundle,\r\n      systemInput->mM.mX,\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mD.mX,\r\n      systemInput->mX.mX, neDiagMgr);\r\n  if (errorId == NULL) {\r\n    double result = 0.0;\r\n    errorId = x2WControl_a151ee3d_1_checkDynamics(\r\n      &smData->mSimRuntimeDerivedValuesBundle,\r\n      systemInput->mX.mX,\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mV.mX + 1,\r\n      systemInput->mD.mX,\r\n      systemInput->mM.mX,\r\n      &result, neDiagMgr);\r\n  }\r\n\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_CIC_MODE_solve(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  NeDaePrivateData *smData = dae->mPrivateData;\r\n  PmfMessageId errorId = NULL;\r\n  double errorResult = 0.0;\r\n  const size_t mvSize = smData->mModeVectorSize;\r\n  boolean_T modeChanged = false;\r\n  if (mvSize > 0) {\r\n    errorId = x2WControl_a151ee3d_1_computeSimModeVector(\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mV.mX + 1,\r\n      systemInput->mM.mX,\r\n      &errorResult,\r\n      neDiagMgr);\r\n    if (errorId != NULL)\r\n      return errorId;\r\n\r\n    {\r\n      size_t i;\r\n      for (i = 0; i < mvSize; ++i)\r\n        if (systemInput->mM.mX[i] != smData->mCachedModeVector.mX[i]) {\r\n          modeChanged = true;\r\n          break;\r\n        }\r\n    }\r\n  }\r\n\r\n  if (modeChanged) {\r\n    errorId = sm_core_onModeChanged(\r\n      &smData->mSimulationDelegate,\r\n      &smData->mSimRuntimeDerivedValuesBundle,\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mD.mX,\r\n      smData->mCachedModeVector.mX,\r\n      systemInput->mM.mX,\r\n      systemInput->mX.mX,\r\n      neDiagMgr);\r\n    if (errorId != NULL)\r\n      return errorId;\r\n    memcpy(smData->mCachedModeVector.mX, systemInput->mM.mX,\r\n           0 * sizeof(int32_T));\r\n  }\r\n\r\n  errorId =\r\n    sm_core_projectState(\r\n    true,\r\n    &smData->mSimulationDelegate,\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    systemInput->mM.mX,\r\n    systemInput->mU.mX,\r\n    systemInput->mU.mX + 1,\r\n    systemInput->mD.mX,\r\n    systemInput->mX.mX, neDiagMgr);\r\n  return errorId;\r\n}\r\n\r\nstatic\r\n  PmfMessageId dae_cg_assemble_solve(const NeDae *dae,\r\n  const NeSystemInput *systemInput,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  NeDaePrivateData *smData = dae->mPrivateData;\r\n  const SmMechanismDelegate *delegate = &smData->mAssemblyDelegate;\r\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle =\r\n    &smData->mAsmRuntimeDerivedValuesBundle;\r\n  PmfMessageId errorId = NULL;\r\n  size_t i;\r\n  double errorResult = 0.0;\r\n  const size_t numTargets = 4;\r\n  unsigned int asmStatus = 0;\r\n  double *assemblyFullStateVector = smData->mAssemblyFullStateVector.mX;\r\n  double *simulationFullStateVector = smData->mSimulationFullStateVector.mX;\r\n  (*delegate->mSetTargets)(runtimeDerivedValuesBundle, smData->mTargets);\r\n\r\n  {\r\n    const double *u = systemInput->mU.mX;\r\n    const double *uDot = u + smData->mInputVectorSize;\r\n    CTarget *target = smData->mTargets + smData->mNumInternalTargets;\r\n    for (i = 0; i < smData->mNumInputMotionPrimitives; ++i) {\r\n      const size_t inputOffset = smData->mMotionInputOffsets.mX[i];\r\n      (target++)->mValue[0] = u [inputOffset];\r\n      (target++)->mValue[0] = uDot[inputOffset];\r\n    }\r\n  }\r\n\r\n  if (smData->mAssemblyModeVector.mN > 0) {\r\n    errorId = x2WControl_a151ee3d_1_computeAsmModeVector(\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mV.mX + 1,\r\n      smData->mAssemblyModeVector.mX,\r\n      &errorResult,\r\n      neDiagMgr);\r\n    if (errorId != NULL)\r\n      return errorId;\r\n  }\r\n\r\n  sm_core_computeStateVector(\r\n    delegate, runtimeDerivedValuesBundle, smData->mAssemblyModeVector.mX,\r\n    numTargets, smData->mTargets, assemblyFullStateVector);\r\n  asmStatus = sm_core_checkAssembly(\r\n    delegate, runtimeDerivedValuesBundle, assemblyFullStateVector,\r\n    smData->mAssemblyModeVector.mX,\r\n    NULL, NULL, NULL);\r\n  if (asmStatus != 1) {\r\n    return sm_ssci_recordRunTimeError(\r\n      \"physmod:sm:ssci:core:dae:dae:assemblyFailure\",\r\n      asmStatus == 2 ?\r\n      \"Model not assembled. The following violation occurred: Position Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly.\"\r\n      :\r\n      (asmStatus == 3 ?\r\n       \"Model not assembled. The following violation occurred: Velocity Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly.\"\r\n       :\r\n       \"Model not assembled. The following violation occurred: Singularity Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly.\"),\r\n      neDiagMgr);\r\n  }\r\n\r\n#if 0\r\n\r\n  x2WControl_a151ee3d_1_checkTargets(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    assemblyFullStateVector);\r\n\r\n#endif\r\n\r\n  if (smData->mModeVectorSize > 0) {\r\n    errorId = x2WControl_a151ee3d_1_computeSimModeVector(\r\n      systemInput->mU.mX,\r\n      systemInput->mU.mX + 1,\r\n      systemInput->mV.mX + 1,\r\n      systemInput->mM.mX,\r\n      &errorResult,\r\n      neDiagMgr);\r\n    if (errorId != NULL)\r\n      return errorId;\r\n    memcpy(smData->mCachedModeVector.mX, systemInput->mM.mX,\r\n           0 * sizeof(int32_T));\r\n  }\r\n\r\n  (*delegate->mConvertStateVector)(\r\n    NULL, runtimeDerivedValuesBundle, NULL, assemblyFullStateVector,\r\n    smData->mAssemblyModeVector.mX, systemInput->mM.mX,\r\n    simulationFullStateVector);\r\n  for (i = 0; i < smData->mStateVectorSize; ++i)\r\n    systemInput->mX.mX[i] = simulationFullStateVector[smData->\r\n      mStateVectorMap.mX[i]];\r\n  memcpy(systemInput->mD.mX,\r\n         simulationFullStateVector +\r\n         smData->mFullStateVectorSize - smData->mDiscreteStateSize,\r\n         smData->mDiscreteStateSize * sizeof(double));\r\n  return errorId;\r\n}\r\n\r\ntypedef struct {\r\n  size_t first;\r\n  size_t second;\r\n} SizePair;\r\n\r\nstatic void checkMemAllocStatus(int_T status)\r\n{\r\n  (void) status;\r\n}\r\n\r\nstatic\r\n  PmCharVector cStringToCharVector(const char *src)\r\n{\r\n  const size_t n = strlen(src);\r\n  PmCharVector charVect;\r\n  const int_T status =\r\n    pm_create_char_vector_fields(&charVect, n + 1, pm_default_allocator());\r\n  checkMemAllocStatus(status);\r\n  strcpy(charVect.mX, src);\r\n  return charVect;\r\n}\r\n\r\nstatic\r\n  void initBasicAttributes(NeDaePrivateData *smData)\r\n{\r\n  size_t i;\r\n  smData->mStateVectorSize = 4;\r\n  smData->mFullStateVectorSize = 4;\r\n  smData->mDiscreteStateSize = 0;\r\n  smData->mModeVectorSize = 0;\r\n  smData->mNumZeroCrossings = 0;\r\n  smData->mInputVectorSize = 1;\r\n  smData->mOutputVectorSize = 1;\r\n  smData->mNumConstraintEqns = 0;\r\n  for (i = 0; i < 4; ++i)\r\n    smData->mChecksum[i] = 0;\r\n}\r\n\r\nstatic\r\n  void initStateVector(NeDaePrivateData *smData)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  const int32_T stateVectorMap[4] = {\r\n    0, 1, 2, 3\r\n  };\r\n\r\n  const CTarget targets[4] = {\r\n    { 0, 56, 0, false, 0, 0, \"1\", false, false, +1.000000000000000000e+00, false,\r\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\r\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\r\n        0.000000000000000000e+00 } },\r\n\r\n    { 0, 56, 0, false, 0, 0, \"1\", true, false, +1.000000000000000000e+00, false,\r\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\r\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\r\n        0.000000000000000000e+00 } },\r\n\r\n    { 0, 57, 0, false, 0, 0, \"1\", false, true, +1.000000000000000000e+00, false,\r\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\r\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\r\n        0.000000000000000000e+00 } },\r\n\r\n    { 0, 57, 0, false, 0, 0, \"1\", true, true, +1.000000000000000000e+00, false,\r\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\r\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\r\n        0.000000000000000000e+00 } }\r\n  };\r\n\r\n  const size_t numTargets = 4;\r\n  int_T status;\r\n  size_t i;\r\n  status = pm_create_real_vector_fields(\r\n    &smData->mAssemblyFullStateVector, 4, alloc);\r\n  checkMemAllocStatus(status);\r\n  status = pm_create_real_vector_fields(\r\n    &smData->mSimulationFullStateVector, 4, alloc);\r\n  checkMemAllocStatus(status);\r\n  status = pm_create_int_vector_fields(\r\n    &smData->mStateVectorMap, smData->mStateVectorSize, alloc);\r\n  checkMemAllocStatus(status);\r\n  memcpy(smData->mStateVectorMap.mX, stateVectorMap,\r\n         smData->mStateVectorSize * sizeof(int32_T));\r\n  smData->mNumInternalTargets = 4;\r\n  smData->mNumInputMotionPrimitives = 0;\r\n  PM_ALLOCATE_ARRAY(smData->mTargets, CTarget, numTargets, alloc);\r\n  for (i = 0; i < numTargets; ++i)\r\n    sm_compiler_CTarget_copy(targets + i, smData->mTargets + i);\r\n}\r\n\r\nstatic void initAsserts(NeDaePrivateData *smData)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  int_T status = 0;\r\n  smData->mNumParamAsserts = 0;\r\n  smData->mParamAssertObjects = NULL;\r\n  smData->mParamAssertPaths = NULL;\r\n  smData->mParamAssertDescriptors = NULL;\r\n  smData->mParamAssertMessages = NULL;\r\n  smData->mParamAssertMessageIds = NULL;\r\n  status = pm_create_bool_vector_fields(\r\n    &smData->mParamAssertIsWarnings, smData->mNumParamAsserts, alloc);\r\n  checkMemAllocStatus(status);\r\n  if (smData->mNumParamAsserts > 0) {\r\n    const NeAssertData *ad = x2WControl_a151ee3d_1_assertData;\r\n    size_t i;\r\n    PM_ALLOCATE_ARRAY(smData->mParamAssertObjects,\r\n                      PmCharVector, 0, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mParamAssertPaths,\r\n                      PmCharVector, 0, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mParamAssertDescriptors,\r\n                      PmCharVector, 0, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mParamAssertMessages,\r\n                      PmCharVector, 0, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mParamAssertMessageIds,\r\n                      PmCharVector, 0, alloc);\r\n    for (i = 0; i < smData->mNumParamAsserts; ++i, ++ad) {\r\n      smData->mParamAssertObjects [i] = cStringToCharVector(ad->mObject );\r\n      smData->mParamAssertPaths [i] = cStringToCharVector(ad->mPath );\r\n      smData->mParamAssertDescriptors[i] = cStringToCharVector(ad->mDescriptor);\r\n      smData->mParamAssertMessages [i] = cStringToCharVector(ad->mMessage );\r\n      smData->mParamAssertMessageIds [i] = cStringToCharVector(ad->mMessageID );\r\n      smData->mParamAssertIsWarnings.mX[i] = ad->mIsWarn;\r\n    }\r\n  }\r\n}\r\n\r\nstatic\r\n  void initModeVector(NeDaePrivateData *smData)\r\n{\r\n  {\r\n    size_t i;\r\n    const int_T status = pm_create_int_vector_fields(\r\n      &smData->mAssemblyModeVector, 0,\r\n      pm_default_allocator());\r\n    checkMemAllocStatus(status);\r\n    for (i = 0; i < smData->mAssemblyModeVector.mN; ++i)\r\n      smData->mAssemblyModeVector.mX[i] = 0;\r\n  }\r\n\r\n  {\r\n    size_t i;\r\n    const int_T status = pm_create_int_vector_fields(\r\n      &smData->mCachedModeVector, 0, pm_default_allocator());\r\n    checkMemAllocStatus(status);\r\n    for (i = 0; i < smData->mModeVectorSize; ++i)\r\n      smData->mCachedModeVector.mX[i] = 0;\r\n  }\r\n}\r\n\r\nstatic void initZeroCrossings(NeDaePrivateData *smData)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  int_T status = 0;\r\n  smData->mZeroCrossingObjects = NULL;\r\n  smData->mZeroCrossingPaths = NULL;\r\n  smData->mZeroCrossingDescriptors = NULL;\r\n  status = pm_create_int_vector_fields(\r\n    &smData->mZeroCrossingTypes, 0, alloc);\r\n  checkMemAllocStatus(status);\r\n  if (smData->mNumZeroCrossings > 0) {\r\n    const NeZCData *zcd = x2WControl_a151ee3d_1_ZCData;\r\n    size_t i;\r\n    PM_ALLOCATE_ARRAY(smData->mZeroCrossingObjects,\r\n                      PmCharVector, 0, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mZeroCrossingPaths,\r\n                      PmCharVector, 0, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mZeroCrossingDescriptors,\r\n                      PmCharVector, 0, alloc);\r\n    for (i = 0; i < smData->mNumZeroCrossings; ++i, ++zcd) {\r\n      smData->mZeroCrossingObjects [i] = cStringToCharVector(zcd->mObject);\r\n      smData->mZeroCrossingPaths [i] = cStringToCharVector(zcd->mPath );\r\n      smData->mZeroCrossingDescriptors[i] = cStringToCharVector(zcd->mDescriptor);\r\n      smData->mZeroCrossingTypes.mX[i] = zcd->mType;\r\n    }\r\n  }\r\n}\r\n\r\nstatic\r\n  void initVariables(NeDaePrivateData *smData)\r\n{\r\n  const char *varFullPaths[4] = {\r\n    \"Prismatic_Joint1.Pz.p\",\r\n    \"Prismatic_Joint1.Pz.v\",\r\n    \"Revolute_Joint.Rz.q\",\r\n    \"Revolute_Joint.Rz.w\"\r\n  };\r\n\r\n  const char *varObjects[4] = {\r\n    \"x2WControl/Prismatic Joint1\",\r\n    \"x2WControl/Prismatic Joint1\",\r\n    \"x2WControl/Revolute Joint\",\r\n    \"x2WControl/Revolute Joint\"\r\n  };\r\n\r\n  smData->mNumVarScalars = 4;\r\n  smData->mVarFullPaths = NULL;\r\n  smData->mVarObjects = NULL;\r\n  if (smData->mNumVarScalars > 0) {\r\n    size_t s;\r\n    PmAllocator *alloc = pm_default_allocator();\r\n    PM_ALLOCATE_ARRAY(smData->mVarFullPaths, PmCharVector, 4, alloc);\r\n    PM_ALLOCATE_ARRAY(smData->mVarObjects, PmCharVector, 4, alloc);\r\n    for (s = 0; s < smData->mNumVarScalars; ++s) {\r\n      smData->mVarFullPaths[s] = cStringToCharVector(varFullPaths[s]);\r\n      smData->mVarObjects[s] = cStringToCharVector(varObjects[s]);\r\n    }\r\n  }\r\n}\r\n\r\nstatic\r\n  void initRuntimeParameters(NeDaePrivateData *smData)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  int_T status = 0;\r\n  size_t i = 0;\r\n  const int32_T *rtpRootVarRows = NULL;\r\n  const int32_T *rtpRootVarCols = NULL;\r\n  const char **rtpFullPaths = NULL;\r\n  smData->mNumRtpRootVars = 0;\r\n  status = pm_create_int_vector_fields(\r\n    &smData->mRtpRootVarRows, smData->mNumRtpRootVars, alloc);\r\n  checkMemAllocStatus(status);\r\n  memcpy(smData->mRtpRootVarRows.mX, rtpRootVarRows,\r\n         smData->mNumRtpRootVars * sizeof(int32_T));\r\n  status = pm_create_int_vector_fields(\r\n    &smData->mRtpRootVarCols, smData->mNumRtpRootVars, alloc);\r\n  checkMemAllocStatus(status);\r\n  memcpy(smData->mRtpRootVarCols.mX, rtpRootVarCols,\r\n         smData->mNumRtpRootVars * sizeof(int32_T));\r\n  smData->mRtpFullPaths = NULL;\r\n  if (smData->mNumRtpRootVars > 0) {\r\n    size_t v;\r\n    PM_ALLOCATE_ARRAY(smData->mRtpFullPaths, PmCharVector, 0, alloc);\r\n    for (v = 0; v < smData->mNumRtpRootVars; ++v) {\r\n      smData->mRtpFullPaths[v] = cStringToCharVector(rtpFullPaths[v]);\r\n    }\r\n  }\r\n\r\n  smData->mNumRuntimeRootVarScalars = 0;\r\n  status = pm_create_real_vector_fields(\r\n    &smData->mRuntimeParameterScalars, 0,\r\n    alloc);\r\n  checkMemAllocStatus(status);\r\n  for (i = 0; i < smData->mRuntimeParameterScalars.mN; ++i)\r\n    smData->mRuntimeParameterScalars.mX[i] = 0.0;\r\n  sm_core_RuntimeDerivedValuesBundle_create(\r\n    &smData->mAsmRuntimeDerivedValuesBundle,\r\n    0,\r\n    0);\r\n  sm_core_RuntimeDerivedValuesBundle_create(\r\n    &smData->mSimRuntimeDerivedValuesBundle,\r\n    0,\r\n    0);\r\n}\r\n\r\nstatic\r\n  void initIoInfoHelper(\r\n  size_t n,\r\n  const char *portPathsSource[],\r\n  const char *unitsSource[],\r\n  const SizePair dimensions[],\r\n  boolean_T doInputs,\r\n  NeDaePrivateData *smData)\r\n{\r\n  PmCharVector *portPaths = NULL;\r\n  PmCharVector *units = NULL;\r\n  SscIoInfo *infos = NULL;\r\n  if (n > 0) {\r\n    size_t s;\r\n    PmAllocator *alloc = pm_default_allocator();\r\n    PM_ALLOCATE_ARRAY(portPaths, PmCharVector, n, alloc);\r\n    PM_ALLOCATE_ARRAY(units, PmCharVector, n, alloc);\r\n    PM_ALLOCATE_ARRAY(infos, SscIoInfo, n, alloc);\r\n    for (s = 0; s < n; ++s) {\r\n      portPaths[s] = cStringToCharVector(portPathsSource[s]);\r\n      units[s] = cStringToCharVector(unitsSource[s]);\r\n\r\n      {\r\n        SscIoInfo *info = infos + s;\r\n        info->mName = info->mIdentifier = portPaths[s].mX;\r\n        ssc_array_size_set_scalar(&info->mSize);\r\n        ssc_array_size_set_dim(&info->mSize, 0, dimensions[s].first);\r\n        ssc_array_size_set_dim(&info->mSize, 1, dimensions[s].second);\r\n        info->mUnit = units[s].mX;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (doInputs) {\r\n    smData->mNumInputs = n;\r\n    smData->mInputPortPaths = portPaths;\r\n    smData->mInputUnits = units;\r\n    smData->mInputInfos = infos;\r\n  } else {\r\n    smData->mNumOutputs = n;\r\n    smData->mOutputPortPaths = portPaths;\r\n    smData->mOutputUnits = units;\r\n    smData->mOutputInfos = infos;\r\n  }\r\n}\r\n\r\nstatic\r\n  void initIoInfo(NeDaePrivateData *smData)\r\n{\r\n  const char *inputPortPaths[1] = {\r\n    \"Prismatic_Joint1.fi\"\r\n  };\r\n\r\n  const char *inputUnits[1] = {\r\n    \"kg*m/s^2\"\r\n  };\r\n\r\n  const SizePair inputDimensions[1] = {\r\n    { 1, 1 }\r\n  };\r\n\r\n  const char *outputPortPaths[1] = {\r\n    \"Revolute_Joint.q\"\r\n  };\r\n\r\n  const char *outputUnits[1] = {\r\n    \"rad\"\r\n  };\r\n\r\n  const SizePair outputDimensions[1] = {\r\n    { 1, 1 }\r\n  };\r\n\r\n  initIoInfoHelper(1, inputPortPaths, inputUnits, inputDimensions,\r\n                   true, smData);\r\n  initIoInfoHelper(1, outputPortPaths, outputUnits, outputDimensions,\r\n                   false, smData);\r\n}\r\n\r\nstatic\r\n  void initInputDerivs(NeDaePrivateData *smData)\r\n{\r\n  const int32_T numInputDerivs[1] = {\r\n    0\r\n  };\r\n\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  const int_T status = pm_create_int_vector_fields(\r\n    &smData->mNumInputDerivs, smData->mInputVectorSize, alloc);\r\n  checkMemAllocStatus(status);\r\n  memcpy(smData->mNumInputDerivs.mX, numInputDerivs,\r\n         1 * sizeof(int32_T));\r\n  smData->mInputOrder = 1;\r\n}\r\n\r\nstatic\r\n  void initDirectFeedthrough(NeDaePrivateData *smData)\r\n{\r\n  const boolean_T directFeedthroughVector[1] = {\r\n    false\r\n  };\r\n\r\n  const boolean_T directFeedthroughMatrix[1] = {\r\n    false\r\n  };\r\n\r\n  PmAllocator *alloc = pm_default_allocator();\r\n\r\n  {\r\n    const int_T status = pm_create_bool_vector_fields(\r\n      &smData->mDirectFeedthroughVector, 1, alloc);\r\n    checkMemAllocStatus(status);\r\n    memcpy(smData->mDirectFeedthroughVector.mX, directFeedthroughVector,\r\n           1 * sizeof(boolean_T));\r\n  }\r\n\r\n  {\r\n    const int_T status = pm_create_bool_vector_fields(\r\n      &smData->mDirectFeedthroughMatrix, 1, alloc);\r\n    checkMemAllocStatus(status);\r\n    memcpy(smData->mDirectFeedthroughMatrix.mX, directFeedthroughMatrix,\r\n           1 * sizeof(boolean_T));\r\n  }\r\n}\r\n\r\nstatic\r\n  void initOutputDerivProc(NeDaePrivateData *smData)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  const int32_T outputFunctionMap[1] = {\r\n    0\r\n  };\r\n\r\n  smData->mOutputFunctionMap = pm_create_int_vector(1, alloc);\r\n  memcpy(smData->mOutputFunctionMap->mX, outputFunctionMap,\r\n         1 * sizeof(int32_T));\r\n  smData->mNumOutputClasses = 1;\r\n  smData->mHasKinematicOutputs = true;\r\n  smData->mHasDynamicOutputs = false;\r\n  smData->mIsOutputClass0Dynamic = false;\r\n  smData->mDoComputeDynamicOutputs = false;\r\n  smData->mCachedDerivativesAvailable = false;\r\n\r\n  {\r\n    size_t i = 0;\r\n    const int_T status = pm_create_real_vector_fields(\r\n      &smData->mCachedDerivatives, 0, pm_default_allocator());\r\n    checkMemAllocStatus(status);\r\n    for (i = 0; i < smData->mCachedDerivatives.mN; ++i)\r\n      smData->mCachedDerivatives.mX[i] = 0.0;\r\n  }\r\n}\r\n\r\n#if 0\r\n\r\nstatic void initializeSizePairVector(const SmSizePair *data,\r\n  SmSizePairVector *vector)\r\n{\r\n  const size_t n = sm_core_SmSizePairVector_size(vector);\r\n  size_t i;\r\n  for (i = 0; i < n; ++i, ++data)\r\n    sm_core_SmSizePairVector_setValue(vector, i, data++);\r\n}\r\n\r\n#endif\r\n\r\nstatic\r\n  void initAssemblyDelegate(SmMechanismDelegate *delegate)\r\n{\r\n  SmMechanismDelegateScratchpad *scratchpad = NULL;\r\n  const SmSizePair jointToStageIdx[2] = {\r\n    { 56, 0 }, { 57, 1 }\r\n  };\r\n\r\n  const size_t primitiveIndices[2 + 1] = {\r\n    0, 1, 2\r\n  };\r\n\r\n  const SmSizePair stateOffsets[2] = {\r\n    { 0, 1 }, { 2, 3 }\r\n  };\r\n\r\n  const SmSizePair dofOffsets[2] = {\r\n    { 0, 1 }, { 1, 2 }\r\n  };\r\n\r\n  const size_t *flexibleStages = NULL;\r\n  const size_t remodIndices[1] = {\r\n    2\r\n  };\r\n\r\n  const size_t *equationsPerConstraint = NULL;\r\n  const int32_T *hasAllVelocityDisabledEquations = NULL;\r\n  const int32_T *runtimeEnabledEquations = NULL;\r\n  const size_t dofToVelSlot[2] = {\r\n    1, 3\r\n  };\r\n\r\n  const size_t *constraintDofs = NULL;\r\n  const size_t constraintDofOffsets[0 + 1] = {\r\n    0\r\n  };\r\n\r\n  const size_t Jm = 0;\r\n  const size_t Jn = 2;\r\n  SmSizePair zeroSizePair;\r\n  zeroSizePair.mFirst = zeroSizePair.mSecond = 0;\r\n  sm_core_MechanismDelegate_allocScratchpad(delegate);\r\n  scratchpad = delegate->mScratchpad;\r\n  delegate->mTargetStrengthFree = 0;\r\n  delegate->mTargetStrengthSuggested = 1;\r\n  delegate->mTargetStrengthDesired = 2;\r\n  delegate->mTargetStrengthRequired = 3;\r\n  delegate->mConsistencyTol = +1.000000000000000062e-09;\r\n  delegate->mTreeJointDof = 2;\r\n  delegate->mDof = 2;\r\n  delegate->mStateSize = 4;\r\n  delegate->mContinuousStateSize = 4;\r\n  delegate->mModeVectorSize = 0;\r\n  delegate->mNumStages = 2;\r\n  delegate->mNumConstraints = 0;\r\n  delegate->mNumAllConstraintEquations = 0;\r\n  sm_core_SmSizePairVector_create(\r\n    &delegate->mJointToStageIdx, 2, &zeroSizePair);\r\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mJointToStageIdx),\r\n         jointToStageIdx, 2 * sizeof(SmSizePair));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mPrimitiveIndices, delegate->mNumStages + 1, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mPrimitiveIndices),\r\n         primitiveIndices, (delegate->mNumStages + 1) * sizeof(size_t));\r\n  sm_core_SmSizePairVector_create(\r\n    &delegate->mStateOffsets, 2, &zeroSizePair);\r\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mStateOffsets),\r\n         stateOffsets, 2 * sizeof(SmSizePair));\r\n  sm_core_SmSizePairVector_create(\r\n    &delegate->mDofOffsets, 2, &zeroSizePair);\r\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mDofOffsets),\r\n         dofOffsets, 2 * sizeof(SmSizePair));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mFlexibleStages, 0, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mFlexibleStages),\r\n         flexibleStages, 0 * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mRemodIndices, 1, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mRemodIndices),\r\n         remodIndices, 1 * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mEquationsPerConstraint, delegate->mNumConstraints, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mEquationsPerConstraint),\r\n         equationsPerConstraint, delegate->mNumConstraints * sizeof(size_t));\r\n  sm_core_SmIntVector_create(\r\n    &delegate->mHasAllVelocityDisabledEquations, delegate->mNumConstraints, 0);\r\n  memcpy(\r\n         sm_core_SmIntVector_nonConstValues\r\n         (&delegate->mHasAllVelocityDisabledEquations),\r\n         hasAllVelocityDisabledEquations, delegate->mNumConstraints * sizeof\r\n         (int32_T));\r\n  sm_core_SmIntVector_create(\r\n    &delegate->mRunTimeEnabledEquations,\r\n    delegate->mNumAllConstraintEquations, 0);\r\n  memcpy(\r\n         sm_core_SmIntVector_nonConstValues(&delegate->mRunTimeEnabledEquations),\r\n         runtimeEnabledEquations, delegate->mNumAllConstraintEquations *\r\n         sizeof(int32_T));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mDofToVelSlot, delegate->mDof, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mDofToVelSlot),\r\n         dofToVelSlot, delegate->mDof * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mConstraintDofs, 0, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofs),\r\n         constraintDofs, 0 * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mConstraintDofOffsets, delegate->mNumConstraints + 1, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofOffsets),\r\n         constraintDofOffsets, (delegate->mNumConstraints + 1) * sizeof(size_t));\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosDesired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggested, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosNonRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggAndFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelDesired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggested, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelNonRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggAndFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mConstraintFilter, 0);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveConstraints, 0);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs0, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mNewConstraints, 0);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mNewDofs, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mUnsatisfiedConstraints, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveConstraintsVect,\r\n    0, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveDofsVect, 2, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mFullDofToActiveDof, 2, 0);\r\n  sm_core_SmSizePairVector_create(\r\n    &scratchpad->mPartiallyPosTargetedPrims, 2, &zeroSizePair);\r\n  sm_core_SmSizePairVector_create(\r\n    &scratchpad->mPartiallyVelTargetedPrims, 2, &zeroSizePair);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mPosPartialTypes, 2, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mVelPartialTypes, 2, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mPartiallyActivePrims, 2, 0);\r\n  sm_core_SmSizePairVector_create(\r\n    &scratchpad->mBaseFrameVelOffsets, 0, &zeroSizePair);\r\n  sm_core_SmSizePairVector_create(&scratchpad->mCvQuaternionVelOffsets,\r\n    0,\r\n    &zeroSizePair);\r\n  sm_core_SmRealVector_create(&scratchpad->mCvQuaternionAzimuthValues,\r\n    0, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mInitialState, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mStartState, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mTestState, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mFullStateVector, 4, 0.0);\r\n  sm_core_SmIntVector_create(&scratchpad->mModeVector, 0, 0);\r\n  sm_core_SmRealVector_create(&scratchpad->mJacobianRowMaj, Jm * Jn, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mJacobian, Jm * Jn, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mJacobianPrimSubmatrix, Jm * 6, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mConstraintNonhomoTerms, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mConstraintError, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mBestConstraintError, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mDeltas,\r\n    Jn * (Jm <= Jn ? Jm : Jn), 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mSvdWork, 9, 0.0);\r\n  sm_core_SmRealVector_create(\r\n    &scratchpad->mLineSearchScaledDeltaVect, 2, 0.0);\r\n  sm_core_SmRealVector_create(\r\n    &scratchpad->mLineSearchTestStateVect, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mLineSearchErrorVect, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mActiveDofVelsVect, 2, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mVelSystemRhs, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mMotionData, 26, 0.0);\r\n  delegate->mSetTargets = x2WControl_a151ee3d_1_setTargets;\r\n  delegate->mResetStateVector = x2WControl_a151ee3d_1_resetAsmStateVector;\r\n  delegate->mInitializeTrackedAngleState =\r\n    x2WControl_a151ee3d_1_initializeTrackedAngleState;\r\n  delegate->mComputeDiscreteState = x2WControl_a151ee3d_1_computeDiscreteState;\r\n  delegate->mAdjustPosition = x2WControl_a151ee3d_1_adjustPosition;\r\n  delegate->mPerturbJointPrimitiveState =\r\n    x2WControl_a151ee3d_1_perturbAsmJointPrimitiveState;\r\n  delegate->mPerturbFlexibleBodyState = NULL;\r\n  delegate->mComputePosDofBlendMatrix =\r\n    x2WControl_a151ee3d_1_computePosDofBlendMatrix;\r\n  delegate->mComputeVelDofBlendMatrix =\r\n    x2WControl_a151ee3d_1_computeVelDofBlendMatrix;\r\n  delegate->mProjectPartiallyTargetedPos =\r\n    x2WControl_a151ee3d_1_projectPartiallyTargetedPos;\r\n  delegate->mPropagateMotion = x2WControl_a151ee3d_1_propagateMotion;\r\n  delegate->mComputeAssemblyError = x2WControl_a151ee3d_1_computeAssemblyError;\r\n  delegate->mComputeAssemblyJacobian =\r\n    x2WControl_a151ee3d_1_computeAssemblyJacobian;\r\n  delegate->mComputeFullAssemblyJacobian =\r\n    x2WControl_a151ee3d_1_computeFullAssemblyJacobian;\r\n  delegate->mIsInKinematicSingularity =\r\n    x2WControl_a151ee3d_1_isInKinematicSingularity;\r\n  delegate->mConvertStateVector = x2WControl_a151ee3d_1_convertStateVector;\r\n  delegate->mConstructStateVector = NULL;\r\n  delegate->mExtractSolverStateVector = NULL;\r\n  delegate->mIsPositionViolation = NULL;\r\n  delegate->mIsVelocityViolation = NULL;\r\n  delegate->mProjectStateSim = NULL;\r\n  delegate->mComputeConstraintError = NULL;\r\n  delegate->mResetModeVector = NULL;\r\n  delegate->mHasJointDisToNormModeChange = NULL;\r\n  delegate->mPerformJointDisToNormModeChange = NULL;\r\n  delegate->mOnModeChangedCutJoints = NULL;\r\n  delegate->mMech = NULL;\r\n}\r\n\r\nstatic\r\n  void initSimulationDelegate(SmMechanismDelegate *delegate)\r\n{\r\n  SmMechanismDelegateScratchpad *scratchpad = NULL;\r\n  const SmSizePair jointToStageIdx[2] = {\r\n    { 56, 0 }, { 57, 1 }\r\n  };\r\n\r\n  const size_t primitiveIndices[2 + 1] = {\r\n    0, 1, 2\r\n  };\r\n\r\n  const SmSizePair stateOffsets[2] = {\r\n    { 0, 1 }, { 2, 3 }\r\n  };\r\n\r\n  const SmSizePair dofOffsets[2] = {\r\n    { 0, 1 }, { 1, 2 }\r\n  };\r\n\r\n  const size_t *flexibleStages = NULL;\r\n  const size_t remodIndices[1] = {\r\n    2\r\n  };\r\n\r\n  const size_t *equationsPerConstraint = NULL;\r\n  const int32_T *hasAllVelocityDisabledEquations = NULL;\r\n  const int32_T *runtimeEnabledEquations = NULL;\r\n  const size_t dofToVelSlot[2] = {\r\n    1, 3\r\n  };\r\n\r\n  const size_t *constraintDofs = NULL;\r\n  const size_t constraintDofOffsets[0 + 1] = {\r\n    0\r\n  };\r\n\r\n  const size_t Jm = 0;\r\n  const size_t Jn = 2;\r\n  SmSizePair zeroSizePair;\r\n  zeroSizePair.mFirst = zeroSizePair.mSecond = 0;\r\n  sm_core_MechanismDelegate_allocScratchpad(delegate);\r\n  scratchpad = delegate->mScratchpad;\r\n  delegate->mTargetStrengthFree = 0;\r\n  delegate->mTargetStrengthSuggested = 1;\r\n  delegate->mTargetStrengthDesired = 2;\r\n  delegate->mTargetStrengthRequired = 3;\r\n  delegate->mConsistencyTol = +1.000000000000000062e-09;\r\n  delegate->mTreeJointDof = 2;\r\n  delegate->mDof = 2;\r\n  delegate->mStateSize = 4;\r\n  delegate->mContinuousStateSize = 4;\r\n  delegate->mModeVectorSize = 0;\r\n  delegate->mNumStages = 2;\r\n  delegate->mNumConstraints = 0;\r\n  delegate->mNumAllConstraintEquations = 0;\r\n  sm_core_SmSizePairVector_create(\r\n    &delegate->mJointToStageIdx, 2, &zeroSizePair);\r\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mJointToStageIdx),\r\n         jointToStageIdx, 2 * sizeof(SmSizePair));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mPrimitiveIndices, delegate->mNumStages + 1, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mPrimitiveIndices),\r\n         primitiveIndices, (delegate->mNumStages + 1) * sizeof(size_t));\r\n  sm_core_SmSizePairVector_create(\r\n    &delegate->mStateOffsets, 2, &zeroSizePair);\r\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mStateOffsets),\r\n         stateOffsets, 2 * sizeof(SmSizePair));\r\n  sm_core_SmSizePairVector_create(\r\n    &delegate->mDofOffsets, 2, &zeroSizePair);\r\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mDofOffsets),\r\n         dofOffsets, 2 * sizeof(SmSizePair));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mFlexibleStages, 0, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mFlexibleStages),\r\n         flexibleStages, 0 * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mRemodIndices, 1, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mRemodIndices),\r\n         remodIndices, 1 * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mEquationsPerConstraint, delegate->mNumConstraints, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mEquationsPerConstraint),\r\n         equationsPerConstraint, delegate->mNumConstraints * sizeof(size_t));\r\n  sm_core_SmIntVector_create(\r\n    &delegate->mHasAllVelocityDisabledEquations, delegate->mNumConstraints, 0);\r\n  memcpy(sm_core_SmIntVector_nonConstValues\r\n         (&delegate->mHasAllVelocityDisabledEquations),\r\n         hasAllVelocityDisabledEquations, delegate->mNumConstraints * sizeof\r\n         (int32_T));\r\n  sm_core_SmIntVector_create(\r\n    &delegate->mRunTimeEnabledEquations,\r\n    delegate->mNumAllConstraintEquations, 0);\r\n  memcpy(\r\n         sm_core_SmIntVector_nonConstValues(&delegate->mRunTimeEnabledEquations),\r\n         runtimeEnabledEquations, delegate->mNumAllConstraintEquations *\r\n         sizeof(int32_T));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mDofToVelSlot, delegate->mDof, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mDofToVelSlot),\r\n         dofToVelSlot, delegate->mDof * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mConstraintDofs, 0, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofs),\r\n         constraintDofs, 0 * sizeof(size_t));\r\n  sm_core_SmSizeTVector_create(\r\n    &delegate->mConstraintDofOffsets, delegate->mNumConstraints + 1, 0);\r\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofOffsets),\r\n         constraintDofOffsets, (delegate->mNumConstraints + 1) * sizeof(size_t));\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosDesired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggested, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosNonRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggAndFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelDesired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggested, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelNonRequired, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggAndFree, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mConstraintFilter, 0);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveConstraints, 0);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs0, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mNewConstraints, 0);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mNewDofs, 2);\r\n  sm_core_SmBoundedSet_create(&scratchpad->mUnsatisfiedConstraints, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveConstraintsVect,\r\n    0, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveDofsVect, 2, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mFullDofToActiveDof, 2, 0);\r\n  sm_core_SmSizePairVector_create(\r\n    &scratchpad->mPartiallyPosTargetedPrims, 2, &zeroSizePair);\r\n  sm_core_SmSizePairVector_create(\r\n    &scratchpad->mPartiallyVelTargetedPrims, 2, &zeroSizePair);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mPosPartialTypes, 2, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mVelPartialTypes, 2, 0);\r\n  sm_core_SmSizeTVector_create(&scratchpad->mPartiallyActivePrims, 2, 0);\r\n  sm_core_SmSizePairVector_create(\r\n    &scratchpad->mBaseFrameVelOffsets, 0, &zeroSizePair);\r\n  sm_core_SmSizePairVector_create(&scratchpad->mCvQuaternionVelOffsets,\r\n    0,\r\n    &zeroSizePair);\r\n  sm_core_SmRealVector_create(&scratchpad->mCvQuaternionAzimuthValues,\r\n    0, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mInitialState, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mStartState, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mTestState, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mFullStateVector, 4, 0.0);\r\n  sm_core_SmIntVector_create(&scratchpad->mModeVector, 0, 0);\r\n  sm_core_SmRealVector_create(&scratchpad->mJacobianRowMaj, Jm * Jn, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mJacobian, Jm * Jn, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mJacobianPrimSubmatrix, Jm * 6, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mConstraintNonhomoTerms, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mConstraintError, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mBestConstraintError, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mDeltas,\r\n    Jn * (Jm <= Jn ? Jm : Jn), 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mSvdWork, 9, 0.0);\r\n  sm_core_SmRealVector_create(\r\n    &scratchpad->mLineSearchScaledDeltaVect, 2, 0.0);\r\n  sm_core_SmRealVector_create(\r\n    &scratchpad->mLineSearchTestStateVect, 4, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mLineSearchErrorVect, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mActiveDofVelsVect, 2, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mVelSystemRhs, Jm, 0.0);\r\n  sm_core_SmRealVector_create(&scratchpad->mMotionData, 26, 0.0);\r\n  delegate->mSetTargets = NULL;\r\n  delegate->mResetStateVector = x2WControl_a151ee3d_1_resetSimStateVector;\r\n  delegate->mInitializeTrackedAngleState = NULL;\r\n  delegate->mComputeDiscreteState = NULL;\r\n  delegate->mAdjustPosition = NULL;\r\n  delegate->mPerturbJointPrimitiveState =\r\n    x2WControl_a151ee3d_1_perturbSimJointPrimitiveState;\r\n  delegate->mPerturbFlexibleBodyState =\r\n    x2WControl_a151ee3d_1_perturbFlexibleBodyState;\r\n  delegate->mComputePosDofBlendMatrix = NULL;\r\n  delegate->mComputeVelDofBlendMatrix = NULL;\r\n  delegate->mProjectPartiallyTargetedPos = NULL;\r\n  delegate->mPropagateMotion = NULL;\r\n  delegate->mComputeAssemblyError = NULL;\r\n  delegate->mComputeAssemblyJacobian = NULL;\r\n  delegate->mComputeFullAssemblyJacobian = NULL;\r\n  delegate->mIsInKinematicSingularity = NULL;\r\n  delegate->mConvertStateVector = NULL;\r\n  delegate->mConstructStateVector = x2WControl_a151ee3d_1_constructStateVector;\r\n  delegate->mExtractSolverStateVector =\r\n    x2WControl_a151ee3d_1_extractSolverStateVector;\r\n  delegate->mIsPositionViolation = x2WControl_a151ee3d_1_isPositionViolation;\r\n  delegate->mIsVelocityViolation = x2WControl_a151ee3d_1_isVelocityViolation;\r\n  delegate->mProjectStateSim = x2WControl_a151ee3d_1_projectStateSim;\r\n  delegate->mComputeConstraintError =\r\n    x2WControl_a151ee3d_1_computeConstraintError;\r\n  delegate->mResetModeVector = x2WControl_a151ee3d_1_resetModeVector;\r\n  delegate->mHasJointDisToNormModeChange =\r\n    x2WControl_a151ee3d_1_hasJointDisToNormModeChange;\r\n  delegate->mPerformJointDisToNormModeChange =\r\n    x2WControl_a151ee3d_1_performJointDisToNormModeChange;\r\n  delegate->mOnModeChangedCutJoints =\r\n    x2WControl_a151ee3d_1_onModeChangedCutJoints;\r\n  delegate->mMech = NULL;\r\n}\r\n\r\nstatic\r\n  void initMechanismDelegates(NeDaePrivateData *smData)\r\n{\r\n  PmAllocator *alloc = pm_default_allocator();\r\n  const int32_T *motionInputOffsets = NULL;\r\n  int_T status = 0;\r\n  initAssemblyDelegate(&smData->mAssemblyDelegate);\r\n  initSimulationDelegate(&smData->mSimulationDelegate);\r\n  status = pm_create_int_vector_fields(\r\n    &smData->mMotionInputOffsets, smData->mNumInputMotionPrimitives, alloc);\r\n  checkMemAllocStatus(status);\r\n  memcpy(smData->mMotionInputOffsets.mX, motionInputOffsets,\r\n         0 * sizeof(int32_T));\r\n}\r\n\r\nstatic\r\n  void initComputationFcnPtrs(NeDaePrivateData *smData)\r\n{\r\n  smData->mSetParametersFcn = dae_cg_setParameters_function;\r\n  smData->mPAssertFcn = dae_cg_pAssert_method;\r\n  smData->mDerivativeFcn = dae_cg_deriv_method;\r\n  smData->mNumJacPerturbLoBoundsFcn = dae_cg_numJacPerturbLoBounds_method;\r\n  smData->mNumJacPerturbHiBoundsFcn = dae_cg_numJacPerturbHiBounds_method;\r\n  smData->mOutputFcn = dae_cg_compOutputs_method;\r\n  smData->mModeFcn = dae_cg_mode_method;\r\n  smData->mZeroCrossingFcn = dae_cg_zeroCrossing_method;\r\n  smData->mProjectionFcn = dae_cg_project_solve;\r\n  smData->mCIC_MODE_Fcn = dae_cg_CIC_MODE_solve;\r\n  smData->mCheckFcn =\r\n    (smData->mStateVectorSize == 0) ? dae_cg_check_solve : NULL;\r\n  smData->mAssemblyFcn = dae_cg_assemble_solve;\r\n  smData->mSetupLoggerFcn = dae_cg_setupLoggerFcn;\r\n  smData->mLogFcn = dae_cg_recordLog_method;\r\n  smData->mResidualsFcn = NULL;\r\n  smData->mLinearizeFcn = NULL;\r\n  smData->mGenerateFcn = NULL;\r\n}\r\n\r\nstatic\r\n  void initLiveLinkToSm(NeDaePrivateData *smData)\r\n{\r\n  smData->mLiveSmLink = NULL;\r\n  smData->mLiveSmLink_destroy = NULL;\r\n  smData->mLiveSmLink_copy = NULL;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_NeDaePrivateData_create(NeDaePrivateData *smData)\r\n{\r\n  initBasicAttributes (smData);\r\n  initStateVector (smData);\r\n  initAsserts (smData);\r\n  initModeVector (smData);\r\n  initZeroCrossings (smData);\r\n  initVariables (smData);\r\n  initRuntimeParameters (smData);\r\n  initIoInfo (smData);\r\n  initInputDerivs (smData);\r\n  initDirectFeedthrough (smData);\r\n  initOutputDerivProc (smData);\r\n  initMechanismDelegates (smData);\r\n  initComputationFcnPtrs (smData);\r\n  initLiveLinkToSm (smData);\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_deriv.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n#include \"x2WControl_a151ee3d_1_geometries.h\"\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_compDerivs(const RuntimeDerivedValuesBundle\r\n  *rtdv, const int *eqnEnableFlags, const double *state, const int *modeVector,\r\n  const double *input, const double *inputDot, const double *inputDdot, const\r\n  double *discreteState, double *deriv, double *errorResult,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  int ii[1];\r\n  double xx[48];\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) modeVector;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) discreteState;\r\n  (void) neDiagMgr;\r\n  xx[0] = 2.0;\r\n  xx[1] = 0.7070996124424118;\r\n  xx[2] = 0.5 * state[2];\r\n  xx[3] = cos(xx[2]);\r\n  xx[4] = 3.184035771019137e-3;\r\n  xx[5] = sin(xx[2]);\r\n  xx[2] = xx[1] * xx[3] - xx[4] * xx[5];\r\n  xx[6] = xx[1] * xx[5];\r\n  xx[1] = xx[4] * xx[3];\r\n  xx[3] = xx[6] + xx[1];\r\n  xx[4] = xx[1] + xx[6];\r\n  xx[1] = 2.538659245956119e-3;\r\n  xx[5] = state[3] * state[3];\r\n  xx[6] = xx[1] * xx[5];\r\n  xx[7] = 4.281311158152548e-3;\r\n  xx[8] = xx[7] * xx[5];\r\n  xx[5] = (5.729577951308231e-3 * state[3] + 7.996472092178835e-3 * xx[6] -\r\n           4.741612338356592e-3 * xx[8]) / 2.343295585686667e-3;\r\n  xx[9] = xx[6] - xx[7] * xx[5];\r\n  xx[6] = xx[9] * xx[3];\r\n  xx[7] = xx[8] + xx[1] * xx[5];\r\n  xx[10] = - xx[6];\r\n  xx[11] = xx[9] * xx[2] - xx[4] * xx[7];\r\n  xx[12] = xx[3] * xx[7];\r\n  pm_math_Vector3_cross_ra(xx + 2, xx + 10, xx + 13);\r\n  xx[1] = xx[2] * xx[2];\r\n  xx[8] = 1.0;\r\n  xx[9] = (xx[1] + xx[1]) * xx[0] - xx[8];\r\n  xx[10] = xx[3] * xx[2];\r\n  xx[11] = xx[4] * xx[2];\r\n  xx[12] = xx[10] - xx[11];\r\n  xx[14] = (xx[11] + xx[10]) * xx[0];\r\n  xx[15] = (xx[10] + xx[11]) * xx[0];\r\n  xx[16] = (xx[1] + xx[3] * xx[3]) * xx[0] - xx[8];\r\n  xx[17] = xx[4] * xx[3];\r\n  xx[18] = xx[0] * (xx[17] - xx[1]);\r\n  xx[19] = xx[0] * (xx[11] - xx[10]);\r\n  xx[10] = xx[17] + xx[1];\r\n  xx[11] = (xx[1] + xx[4] * xx[4]) * xx[0] - xx[8];\r\n  xx[20] = xx[9];\r\n  xx[21] = xx[0] * xx[12];\r\n  xx[22] = xx[14];\r\n  xx[23] = xx[15];\r\n  xx[24] = xx[16];\r\n  xx[25] = xx[18];\r\n  xx[26] = xx[19];\r\n  xx[27] = xx[10] * xx[0];\r\n  xx[28] = xx[11];\r\n  xx[1] = 0.5326496893663588;\r\n  xx[8] = 4.638249746573962e-3;\r\n  xx[17] = 1.0708;\r\n  xx[29] = 0.5275778433139708;\r\n  xx[30] = xx[1] * xx[9] + xx[8] * xx[14];\r\n  xx[31] = xx[1] * xx[15] + xx[8] * xx[18];\r\n  xx[32] = xx[1] * xx[19] + xx[8] * xx[11];\r\n  xx[33] = xx[17] * xx[12];\r\n  xx[34] = 0.5354 * xx[16];\r\n  xx[35] = xx[10] * xx[17];\r\n  xx[36] = xx[8] * xx[9] + xx[29] * xx[14];\r\n  xx[37] = xx[8] * xx[15] + xx[29] * xx[18];\r\n  xx[38] = xx[8] * xx[19] + xx[29] * xx[11];\r\n  pm_math_Matrix3x3_compose_ra(xx + 20, xx + 30, xx + 39);\r\n  xx[1] = 0.1566 + xx[39];\r\n  memcpy(xx + 8, xx + 1, 1 * sizeof(double));\r\n  ii[0] = factorSymmetricPosDef(xx + 8, 1, xx + 9);\r\n  if (ii[0] != 0) {\r\n    return sm_ssci_recordRunTimeError(\r\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassFoll\",\r\n      \"'x2WControl/Prismatic Joint1' has a degenerate mass distribution on its follower side.\",\r\n      neDiagMgr);\r\n  }\r\n\r\n  xx[9] = 9.806650000000001;\r\n  xx[10] = 1.77635683940025e-15;\r\n  xx[11] = (input[0] + xx[0] * (xx[13] - xx[6] * xx[2]) - xx[7]) / xx[8] + xx[9]\r\n    * xx[45] / xx[8] - xx[10] * xx[1] / xx[8];\r\n  xx[1] = xx[3] * xx[9];\r\n  xx[6] = xx[10] + xx[11];\r\n  xx[7] = xx[3] * xx[6];\r\n  xx[12] = xx[1];\r\n  xx[13] = - (xx[4] * xx[6] + xx[9] * xx[2]);\r\n  xx[14] = xx[7];\r\n  pm_math_Vector3_cross_ra(xx + 2, xx + 12, xx + 15);\r\n  deriv[0] = state[1];\r\n  deriv[1] = xx[11];\r\n  deriv[2] = state[3];\r\n  deriv[3] = - (xx[5] + (xx[0] * (xx[15] - xx[1] * xx[2]) - xx[6]) *\r\n                1.083371326034485 - (xx[9] + (xx[17] - xx[7] * xx[2]) * xx[0]) *\r\n                1.827046994968829);\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_numJacPerturbLoBounds(const\r\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\r\n  *state, const int *modeVector, const double *input, const double *inputDot,\r\n  const double *inputDdot, const double *discreteState, double *bounds, double\r\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  double xx[2];\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) state;\r\n  (void) modeVector;\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) discreteState;\r\n  (void) neDiagMgr;\r\n  xx[0] = 1.0e-9;\r\n  xx[1] = 1.0e-8;\r\n  bounds[0] = xx[0];\r\n  bounds[1] = xx[0];\r\n  bounds[2] = xx[1];\r\n  bounds[3] = xx[1];\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_numJacPerturbHiBounds(const\r\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\r\n  *state, const int *modeVector, const double *input, const double *inputDot,\r\n  const double *inputDdot, const double *discreteState, double *bounds, double\r\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  double xx[1];\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) state;\r\n  (void) modeVector;\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) discreteState;\r\n  (void) neDiagMgr;\r\n  xx[0] = +pmf_get_inf();\r\n  bounds[0] = xx[0];\r\n  bounds[1] = xx[0];\r\n  bounds[2] = 1.0;\r\n  bounds[3] = xx[0];\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_gateway.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#ifdef MATLAB_MEX_FILE\r\n#include \"tmwtypes.h\"\r\n#else\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"nesl_rtw.h\"\r\n#include \"x2WControl_a151ee3d_1.h\"\r\n#include \"x2WControl_a151ee3d_1_gateway.h\"\r\n\r\nvoid x2WControl_a151ee3d_1_gateway(void)\r\n{\r\n  NeModelParameters modelparams = { (NeSolverType) 0, 0.001, 0.001, 0.001, 0, 0,\r\n    (NeModifyAbsTol) 0, 0.001, 0, 0, 0, 0, (SscLoggingSetting) 1, 607273323, 1,\r\n    0, };\r\n\r\n  NeSolverParameters solverparams = { 0, (NeMBLocalSolverChoice) 0, 0.001, 0, 0,\r\n    1, 0, 0, 0.001, 1e-06, 1e-09, 0, 0, 100, 0, 1, (NeConsistencySolver) 2,\r\n    (NeIndexReductionMethod) 1, 0, 1e-09, (NeToleranceSource) 1, 0.001, 0.001,\r\n    0.001, 0, (NeLocalSolverChoice) 0, 1, 1, 0.001, 0, 3, 2, 0, 2,\r\n    (NeLinearAlgebraChoice) 1, 0, (NeEquationFormulationChoice) 0, 1024, 1,\r\n    0.001, (NePartitionStorageMethod) 0, 1024, (NePartitionMethod) 1, };\r\n\r\n  const NeOutputParameters* outputparameters = NULL;\r\n  NeDae* dae;\r\n  size_t numOutputs = 0;\r\n  int* rtpDaes = NULL;\r\n  int rtwLogDaes[1] = { 0 };\r\n\r\n  {\r\n    static const NeOutputParameters outputparameters_init[] = { { 0, 0, }, };\r\n\r\n    outputparameters = outputparameters_init;\r\n    numOutputs = sizeof(outputparameters_init)/sizeof(outputparameters_init[0]);\r\n  }\r\n\r\n  x2WControl_a151ee3d_1_dae(&dae,\r\n    &modelparams,\r\n    &solverparams);\r\n  nesl_register_simulator_group(\"x2WControl/Solver Configuration_1\",\r\n    1,\r\n    &dae,\r\n    &solverparams,\r\n    &modelparams,\r\n    numOutputs,\r\n    outputparameters,\r\n    0,\r\n    rtpDaes,\r\n    1,\r\n    rtwLogDaes);\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_gateway.h","type":"header","group":"other","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#ifndef __x2WControl_a151ee3d_1_gateway_h__\r\n#define __x2WControl_a151ee3d_1_gateway_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern void x2WControl_a151ee3d_1_gateway(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n#endif                         /* #ifndef __x2WControl_a151ee3d_1_gateway_h__ */\r\n"},{"name":"x2WControl_a151ee3d_1_geometries.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n\r\nvoid x2WControl_a151ee3d_1_initializeGeometries(const struct\r\n  RuntimeDerivedValuesBundleTag *rtdv)\r\n{\r\n  (void) rtdv;\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_geometries.h","type":"header","group":"other","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\nstruct RuntimeDerivedValuesBundleTag;\r\nvoid x2WControl_a151ee3d_1_initializeGeometries(const struct\r\n  RuntimeDerivedValuesBundleTag *rtdv);\r\n"},{"name":"x2WControl_a151ee3d_1_logging.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n#include \"x2WControl_a151ee3d_1_geometries.h\"\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_recordLog(const RuntimeDerivedValuesBundle\r\n  *rtdv, const int *eqnEnableFlags, const double *state, const int *modeVector,\r\n  const double *input, const double *inputDot, const double *inputDdot, double\r\n  *logVector, double *errorResult, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  int ii[1];\r\n  double xx[49];\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) modeVector;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) neDiagMgr;\r\n  xx[0] = 57.29577951308232;\r\n  xx[1] = 2.0;\r\n  xx[2] = 0.7070996124424118;\r\n  xx[3] = 0.5 * state[2];\r\n  xx[4] = cos(xx[3]);\r\n  xx[5] = 3.184035771019137e-3;\r\n  xx[6] = sin(xx[3]);\r\n  xx[3] = xx[2] * xx[4] - xx[5] * xx[6];\r\n  xx[7] = xx[2] * xx[6];\r\n  xx[2] = xx[5] * xx[4];\r\n  xx[4] = xx[7] + xx[2];\r\n  xx[5] = xx[2] + xx[7];\r\n  xx[2] = 2.538659245956119e-3;\r\n  xx[6] = state[3] * state[3];\r\n  xx[7] = xx[2] * xx[6];\r\n  xx[8] = 4.281311158152548e-3;\r\n  xx[9] = xx[8] * xx[6];\r\n  xx[6] = (5.729577951308231e-3 * state[3] + 7.996472092178835e-3 * xx[7] -\r\n           4.741612338356592e-3 * xx[9]) / 2.343295585686667e-3;\r\n  xx[10] = xx[7] - xx[8] * xx[6];\r\n  xx[7] = xx[10] * xx[4];\r\n  xx[8] = xx[9] + xx[2] * xx[6];\r\n  xx[11] = - xx[7];\r\n  xx[12] = xx[10] * xx[3] - xx[5] * xx[8];\r\n  xx[13] = xx[4] * xx[8];\r\n  pm_math_Vector3_cross_ra(xx + 3, xx + 11, xx + 14);\r\n  xx[2] = xx[3] * xx[3];\r\n  xx[9] = 1.0;\r\n  xx[10] = (xx[2] + xx[2]) * xx[1] - xx[9];\r\n  xx[11] = xx[4] * xx[3];\r\n  xx[12] = xx[5] * xx[3];\r\n  xx[13] = xx[11] - xx[12];\r\n  xx[15] = (xx[12] + xx[11]) * xx[1];\r\n  xx[16] = (xx[11] + xx[12]) * xx[1];\r\n  xx[17] = (xx[2] + xx[4] * xx[4]) * xx[1] - xx[9];\r\n  xx[18] = xx[5] * xx[4];\r\n  xx[19] = xx[1] * (xx[18] - xx[2]);\r\n  xx[20] = xx[1] * (xx[12] - xx[11]);\r\n  xx[11] = xx[18] + xx[2];\r\n  xx[12] = (xx[2] + xx[5] * xx[5]) * xx[1] - xx[9];\r\n  xx[21] = xx[10];\r\n  xx[22] = xx[1] * xx[13];\r\n  xx[23] = xx[15];\r\n  xx[24] = xx[16];\r\n  xx[25] = xx[17];\r\n  xx[26] = xx[19];\r\n  xx[27] = xx[20];\r\n  xx[28] = xx[11] * xx[1];\r\n  xx[29] = xx[12];\r\n  xx[2] = 0.5326496893663588;\r\n  xx[9] = 4.638249746573962e-3;\r\n  xx[18] = 1.0708;\r\n  xx[30] = 0.5275778433139708;\r\n  xx[31] = xx[2] * xx[10] + xx[9] * xx[15];\r\n  xx[32] = xx[2] * xx[16] + xx[9] * xx[19];\r\n  xx[33] = xx[2] * xx[20] + xx[9] * xx[12];\r\n  xx[34] = xx[18] * xx[13];\r\n  xx[35] = 0.5354 * xx[17];\r\n  xx[36] = xx[11] * xx[18];\r\n  xx[37] = xx[9] * xx[10] + xx[30] * xx[15];\r\n  xx[38] = xx[9] * xx[16] + xx[30] * xx[19];\r\n  xx[39] = xx[9] * xx[20] + xx[30] * xx[12];\r\n  pm_math_Matrix3x3_compose_ra(xx + 21, xx + 31, xx + 40);\r\n  xx[2] = 0.1566 + xx[40];\r\n  memcpy(xx + 9, xx + 2, 1 * sizeof(double));\r\n  ii[0] = factorSymmetricPosDef(xx + 9, 1, xx + 10);\r\n  if (ii[0] != 0) {\r\n    return sm_ssci_recordRunTimeError(\r\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassFoll\",\r\n      \"'x2WControl/Prismatic Joint1' has a degenerate mass distribution on its follower side.\",\r\n      neDiagMgr);\r\n  }\r\n\r\n  xx[10] = 9.806650000000001;\r\n  xx[11] = 1.77635683940025e-15;\r\n  xx[12] = (input[0] + xx[1] * (xx[14] - xx[7] * xx[3]) - xx[8]) / xx[9] + xx[10]\r\n    * xx[46] / xx[9] - xx[11] * xx[2] / xx[9];\r\n  xx[2] = xx[4] * xx[10];\r\n  xx[7] = xx[11] + xx[12];\r\n  xx[8] = xx[4] * xx[7];\r\n  xx[13] = xx[2];\r\n  xx[14] = - (xx[5] * xx[7] + xx[10] * xx[3]);\r\n  xx[15] = xx[8];\r\n  pm_math_Vector3_cross_ra(xx + 3, xx + 13, xx + 16);\r\n  logVector[0] = state[0];\r\n  logVector[1] = state[1];\r\n  logVector[2] = xx[0] * state[2];\r\n  logVector[3] = xx[0] * state[3];\r\n  logVector[4] = xx[12];\r\n  logVector[5] = - ((xx[6] + (xx[1] * (xx[16] - xx[2] * xx[3]) - xx[7]) *\r\n                     1.083371326034485 - (xx[10] + (xx[18] - xx[8] * xx[3]) *\r\n    xx[1]) * 1.827046994968829) * xx[0]);\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_mode_zero_crossings.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n#include \"x2WControl_a151ee3d_1_geometries.h\"\r\n\r\nconst NeZCData *x2WControl_a151ee3d_1_ZCData = NULL;\r\nPmfMessageId x2WControl_a151ee3d_1_computeAsmModeVector(const double *input,\r\n  const double *inputDot, const double *inputDdot, int *modeVector, double\r\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) modeVector;\r\n  (void) neDiagMgr;\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_computeSimModeVector(const double *input,\r\n  const double *inputDot, const double *inputDdot, int *modeVector, double\r\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) modeVector;\r\n  (void) neDiagMgr;\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_computeZeroCrossings(const\r\n  RuntimeDerivedValuesBundle *rtdv, const double *solverStateVector, const\r\n  double *input, const double *inputDot, const double *inputDdot, const double\r\n  *discreteStateVector, double *zeroCrossingsVector, double *errorResult,\r\n  NeuDiagnosticManager *neDiagMgr)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) solverStateVector;\r\n  (void) input;\r\n  (void) inputDot;\r\n  (void) inputDdot;\r\n  (void) discreteStateVector;\r\n  (void) zeroCrossingsVector;\r\n  (void) neDiagMgr;\r\n  errorResult[0] = 0.0;\r\n  return NULL;\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_setParameters.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n\r\nvoid x2WControl_a151ee3d_1_computeRuntimeParameters(real_T *in, real_T *out)\r\n{\r\n  (void) in;\r\n  (void) out;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValuesDoubles(const double\r\n  *rtp, double *rtdvd)\r\n{\r\n  (void) rtp;\r\n  (void) rtdvd;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValuesInts(const double *rtp,\r\n  int *rtdvi)\r\n{\r\n  (void) rtp;\r\n  (void) rtdvi;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValues(const double *rtp,\r\n  RuntimeDerivedValuesBundle *rtdv)\r\n{\r\n  x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValuesDoubles(rtp,\r\n    rtdv->mDoubles.mValues);\r\n  x2WControl_a151ee3d_1_computeAsmRuntimeDerivedValuesInts(rtp,\r\n    rtdv->mInts.mValues);\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeSimRuntimeDerivedValuesDoubles(const double\r\n  *rtp, double *rtdvd)\r\n{\r\n  (void) rtp;\r\n  (void) rtdvd;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeSimRuntimeDerivedValuesInts(const double *rtp,\r\n  int *rtdvi)\r\n{\r\n  (void) rtp;\r\n  (void) rtdvi;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeSimRuntimeDerivedValues(const double *rtp,\r\n  RuntimeDerivedValuesBundle *rtdv)\r\n{\r\n  x2WControl_a151ee3d_1_computeSimRuntimeDerivedValuesDoubles(rtp,\r\n    rtdv->mDoubles.mValues);\r\n  x2WControl_a151ee3d_1_computeSimRuntimeDerivedValuesInts(rtp,\r\n    rtdv->mInts.mValues);\r\n}\r\n"},{"name":"x2WControl_a151ee3d_1_sim_delegate.c","type":"source","group":"legacy","path":"C:\\Users\\sohai\\Downloads\\x2WControl_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'x2WControl/Solver Configuration'.\r\n */\r\n\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"pm_std.h\"\r\n#include \"sm_std.h\"\r\n#include \"ne_std.h\"\r\n#include \"ne_dae.h\"\r\n#include \"sm_ssci_run_time_errors.h\"\r\n#include \"sm_RuntimeDerivedValuesBundle.h\"\r\n\r\nvoid x2WControl_a151ee3d_1_resetSimStateVector(const void *mech, double *state)\r\n{\r\n  double xx[1];\r\n  (void) mech;\r\n  xx[0] = 0.0;\r\n  state[0] = xx[0];\r\n  state[1] = xx[0];\r\n  state[2] = xx[0];\r\n  state[3] = xx[0];\r\n}\r\n\r\nstatic void perturbSimJointPrimitiveState_0_0(double mag, double *state)\r\n{\r\n  state[0] = state[0] + mag;\r\n}\r\n\r\nstatic void perturbSimJointPrimitiveState_0_0v(double mag, double *state)\r\n{\r\n  state[0] = state[0] + mag;\r\n  state[1] = state[1] - 0.875 * mag;\r\n}\r\n\r\nstatic void perturbSimJointPrimitiveState_1_0(double mag, double *state)\r\n{\r\n  state[2] = state[2] + mag;\r\n}\r\n\r\nstatic void perturbSimJointPrimitiveState_1_0v(double mag, double *state)\r\n{\r\n  state[2] = state[2] + mag;\r\n  state[3] = state[3] - 0.875 * mag;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_perturbSimJointPrimitiveState(const void *mech,\r\n  size_t stageIdx, size_t primIdx, double mag, boolean_T doPerturbVelocity,\r\n  double *state)\r\n{\r\n  (void) mech;\r\n  (void) stageIdx;\r\n  (void) primIdx;\r\n  (void) mag;\r\n  (void) doPerturbVelocity;\r\n  (void) state;\r\n  switch ((stageIdx * 6 + primIdx) * 2 + (doPerturbVelocity ? 1 : 0))\r\n  {\r\n   case 0:\r\n    perturbSimJointPrimitiveState_0_0(mag, state);\r\n    break;\r\n\r\n   case 1:\r\n    perturbSimJointPrimitiveState_0_0v(mag, state);\r\n    break;\r\n\r\n   case 12:\r\n    perturbSimJointPrimitiveState_1_0(mag, state);\r\n    break;\r\n\r\n   case 13:\r\n    perturbSimJointPrimitiveState_1_0v(mag, state);\r\n    break;\r\n  }\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_perturbFlexibleBodyState(const void *mech, size_t\r\n  stageIdx, double mag, boolean_T doPerturbVelocity, double *state)\r\n{\r\n  (void) mech;\r\n  (void) stageIdx;\r\n  (void) mag;\r\n  (void) doPerturbVelocity;\r\n  (void) state;\r\n  switch (stageIdx * 2 + (doPerturbVelocity ? 1 : 0))\r\n  {\r\n  }\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_constructStateVector(const void *mech, const double\r\n  *solverState, const double *u, const double *uDot, double *discreteState,\r\n  double *fullState)\r\n{\r\n  (void) mech;\r\n  (void) u;\r\n  (void) uDot;\r\n  (void) discreteState;\r\n  fullState[0] = solverState[0];\r\n  fullState[1] = solverState[1];\r\n  fullState[2] = solverState[2];\r\n  fullState[3] = solverState[3];\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_extractSolverStateVector(const void *mech, const\r\n  double *fullState, double *solverState)\r\n{\r\n  (void) mech;\r\n  solverState[0] = fullState[0];\r\n  solverState[1] = fullState[1];\r\n  solverState[2] = fullState[2];\r\n  solverState[3] = fullState[3];\r\n}\r\n\r\nboolean_T x2WControl_a151ee3d_1_isPositionViolation(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\r\n  *state, const int *modeVector)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) state;\r\n  (void) modeVector;\r\n  return 0;\r\n}\r\n\r\nboolean_T x2WControl_a151ee3d_1_isVelocityViolation(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\r\n  *state, const int *modeVector)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) state;\r\n  (void) modeVector;\r\n  return 0;\r\n}\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_projectStateSim(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const int\r\n  *modeVector, double *state, void *neDiagMgr0)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  NeuDiagnosticManager *neDiagMgr = (NeuDiagnosticManager *) neDiagMgr0;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) modeVector;\r\n  (void) state;\r\n  (void) neDiagMgr;\r\n  return NULL;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_computeConstraintError(const void *mech, const\r\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const int *modeVector,\r\n  double *error)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) state;\r\n  (void) modeVector;\r\n  (void) error;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_resetModeVector(const void *mech, int *modeVector)\r\n{\r\n  (void) mech;\r\n  (void) modeVector;\r\n}\r\n\r\nboolean_T x2WControl_a151ee3d_1_hasJointDisToNormModeChange(const void *mech,\r\n  const int *prevModeVector, const int *modeVector)\r\n{\r\n  (void) mech;\r\n  (void) prevModeVector;\r\n  (void) modeVector;\r\n  return 0;\r\n}\r\n\r\nPmfMessageId x2WControl_a151ee3d_1_performJointDisToNormModeChange(const void\r\n  *mech, const RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags,\r\n  const int *prevModeVector, const int *modeVector, const double *input, double *\r\n  state, void *neDiagMgr0)\r\n{\r\n  const double *rtdvd = rtdv->mDoubles.mValues;\r\n  const int *rtdvi = rtdv->mInts.mValues;\r\n  NeuDiagnosticManager *neDiagMgr = (NeuDiagnosticManager *) neDiagMgr0;\r\n  (void) mech;\r\n  (void) rtdvd;\r\n  (void) rtdvi;\r\n  (void) eqnEnableFlags;\r\n  (void) prevModeVector;\r\n  (void) modeVector;\r\n  (void) input;\r\n  (void) state;\r\n  (void) neDiagMgr;\r\n  return NULL;\r\n}\r\n\r\nvoid x2WControl_a151ee3d_1_onModeChangedCutJoints(const void *mech, const int\r\n  *prevModeVector, const int *modeVector, double *state)\r\n{\r\n  (void) mech;\r\n  (void) prevModeVector;\r\n  (void) modeVector;\r\n  (void) state;\r\n}\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};